<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8"/>
<title>Células de Crecimiento | Zona</title>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<link rel="stylesheet"
      href="https://cdn.datatables.net/1.13.8/css/jquery.dataTables.min.css"/>
<style>
/* -------- Estilos CSS -------- */
/* Estilos del body: Define la fuente por defecto, elimina el margen y establece el color de fondo. */
body{font-family:system-ui,Arial,sans-serif;margin:0;background:#fafafa}

/* Estilos del banner del encabezado: Asegura que la imagen del banner sea responsiva y se ajuste bien. */
header .banner{display:block;width:100%;height:auto;max-height:25vh;object-fit:contain;margin:0}

/* Estilos del contenedor de controles: Para el filtro de zona y la entrada de búsqueda de dirección. Usa flexbox para el diseño. */
.controls{margin:1rem 2rem;display:flex;flex-wrap:wrap;gap:.75rem;align-items:center}
/* Estilos para el menú desplegable de selección y la entrada de texto: Relleno, tamaño de fuente, borde. */
#zonaSelect,#homeInput{padding:.35rem .6rem;font-size:1rem;border:1px solid #ccc;border-radius:4px}
/* Estilos para la entrada de dirección de casa: Ancho mínimo y propiedades flex para responsividad. */
#homeInput{min-width:260px;flex:1 1 260px}
/* Color del texto del placeholder para la entrada de dirección. */
#homeInput::placeholder{color:#999}
/* Estilos del botón de búsqueda: Relleno, fuente, borde, fondo, color, cursor. */
#searchBtn{padding:.35rem .9rem;font-size:1rem;border:1px solid #2d57a3;background:#2d57a3;color:#fff;border-radius:4px;cursor:pointer}
/* Estilos para el botón de búsqueda cuando está deshabilitado: Opacidad reducida y cursor 'not-allowed'. */
#searchBtn:disabled{opacity:.5;cursor:not-allowed}

/* Estilos del contenedor de la tabla: Altura fija, habilita el desplazamiento para el desbordamiento, relleno. */
.table-wrapper{height:65vh;overflow:auto;padding:0 2rem 1.5rem}
/* Estilos de DataTable: Borde, colapso de borde, ancho, diseño de tabla. */
table.dataTable{border:2px solid #13284b;border-collapse:collapse;width:100%;table-layout:fixed}
/* Estilos de las celdas del encabezado de DataTable: Fondo, color, borde, grosor de fuente, alineación de texto. */
table.dataTable thead th{background:#2d57a3;color:#fff;border:1px solid #13284b;font-weight:700;text-align:center}
/* Estilos de las celdas de datos de DataTable: Borde, relleno, ajuste de palabra para texto largo. */
table.dataTable td{border:1px solid #ccc;padding:6px 4px;word-wrap:break-word}
/* Estilo para la primera celda en cada fila del cuerpo (típicamente la columna '#'): Fondo, grosor de fuente, alineación. */
table.dataTable tbody td:nth-child(1){background:#eee;font-weight:700;text-align:center}
/* Rayado tipo cebra para filas pares en el cuerpo de DataTable. */
table.dataTable tbody tr:nth-child(even) td{background:#f8f8f8}

/* Estilos del contenedor de tarjetas (para vista móvil): Inicialmente oculto, relleno, desplazamiento, altura fija. */
.cards{display:none;padding:0 1rem 2rem;overflow:auto;height:65vh}
/* Estilos de tarjetas individuales: Borde, radio, margen, relleno, fondo, sombra. */
.card{border:1px solid #ccc;border-radius:6px;margin-bottom:1rem;padding:1rem;background:#fff;box-shadow:0 1px 3px rgba(0,0,0,.05)}
/* Estilos de párrafos dentro de las tarjetas: Margen, tamaño de fuente. */
.card p{margin:.25rem 0;font-size:.95rem}

/* Media query para pantallas más pequeñas (ancho máximo 900px): Oculta la tabla, muestra las tarjetas, ajusta el margen de los controles. */
@media(max-width:900px){
  .table-wrapper{display:none} /* Ocultar el contenedor de la tabla */
  .cards{display:block}       /* Mostrar el contenedor de las tarjetas */
  .controls{margin:1rem}      /* Ajustar el margen para el área de controles */
}

/* Estilos para el div del mensaje de 'célula más cercana'. */
#nearest{margin:.5rem 2rem 0;font-weight:600}
/* Estilos para el div del mensaje de error. */
#error{color:#c00;margin:1rem 2rem 0;font-weight:700}
</style>
</head>
<body>
<header>
  <img src="./header.svg" class="banner" alt="La Cosecha – Células">
</header>

<div class="controls">
  <label for="zonaSelect"><strong>Zona:</strong></label>
  <select id="zonaSelect"><option value="">— Todas —</option></select> <label for="homeInput" class="addr-label">Buscar dirección más cercana:</label>
  <input id="homeInput" type="text" placeholder="Dirección de casa"/> <button id="searchBtn">Buscar</button> </div>

<div id="nearest"></div>

<div class="table-wrapper"><table id="tabla" class="display"></table></div>
<div id="cards"  class="cards"></div>
<div id="error"  hidden></div>

<script src="./xlsx.full.min.js"></script> <script src="https://code.jquery.com/jquery-3.7.1.min.js"></script> <script src="https://cdn.datatables.net/1.13.8/js/jquery.dataTables.min.js"></script> <script async defer
  src="https://maps.googleapis.com/maps/api/js?key=AIzaSyC4LU0O02a7lCRtZeyGbigQQcJ4EuSKa7A&libraries=places&callback=gmapsReady">
</script>

<script>
/* ==========================================================================
   Lógica JavaScript para la Aplicación Buscador de Células
   ========================================================================== */

/* ---------- CONSTANTES GLOBALES ---------- */
// HUB_ADDR: La dirección física de la iglesia (La Cosecha).
// Se usa como el origen por defecto para calcular los tiempos de viaje a las células
// y como la ubicación específica para las células en la zona "La Cosecha".
const HUB_ADDR = '600 Greenwich St, Hempstead, NY 11550';

/* ---------- ESTADO GLOBAL DE LA APLICACIÓN ---------- */
// headES: Array para almacenar los encabezados de las columnas extraídos de la hoja de Excel.
// Ejemplo: ['#', 'ZONA', 'LIDER', 'DIRECCION', ...]
let headES = [];

// rows: Array de objetos, donde cada objeto representa una célula (grupo de estudio bíblico).
// Las propiedades de cada objeto corresponden a los encabezados en 'headES'.
// Este array se llena mediante loadSheet() y es la fuente de datos principal.
// Propiedades adicionales como 'ETA_FROM_HUB', 'ETA_FROM_HOME', etc., se añaden durante el procesamiento.
let rows = [];

// table: Variable para mantener la instancia inicializada de DataTables.
// Permite interactuar con la API de la tabla (ej., table.clear(), table.rows.add()).
let table;

// cardsDiv: Referencia al elemento DOM (div) donde se renderizan las tarjetas de información de las células para la vista móvil.
let cardsDiv;

// geocoder: Instancia de google.maps.Geocoder. Se usa para convertir direcciones textuales en coordenadas geográficas (latitud/longitud).
let geocoder;

// distSvc: Instancia de google.maps.DistanceMatrixService. Se usa para calcular la distancia y el tiempo de viaje entre orígenes y destinos.
let distSvc;

// homePos: Almacena las coordenadas geográficas {lat, lng} de la dirección de casa introducida por el usuario.
// Es null inicialmente o si la dirección es inválida/borrada. Este estado determina los cálculos de ETA.
let homePos = null;

// geoCache: Un objeto Map de JavaScript usado para cachear los resultados de la geocodificación de direcciones.
// Clave: cadena de dirección, Valor: objeto {lat, lng} o null (si la geocodificación falló).
// Esto ayuda a reducir llamadas redundantes a la API del servicio de Geocodificación, ahorrando cuotas y mejorando el rendimiento.
const geoCache = new Map();

/* ---------- INICIALIZACIÓN DE GOOGLE MAPS ---------- */
// Esta función se designa como el callback para el script de la API de Google Maps.
// Se ejecuta una vez que la API de Google Maps (incluida la biblioteca Places) está completamente cargada y lista.
async function gmapsReady() {
  // Inicializar los servicios de Geocoder y DistanceMatrixService de Google Maps.
  geocoder = new google.maps.Geocoder();
  distSvc = new google.maps.DistanceMatrixService();
  
  // Cargar y procesar de forma asíncrona los datos del archivo 'celulas.xlsx'.
  // Esta función también llama a buildUI() tras la carga exitosa de los datos.
  await loadSheet();

  // Obtener el elemento DOM del campo de entrada de la dirección de casa.
  const autocompleteInput = document.getElementById('homeInput');
  // Inicializar Google Places Autocomplete en el campo de entrada.
  // 'types: ['geocode']' restringe las sugerencias a resultados de geocodificación (direcciones).
  const ac = new google.maps.places.Autocomplete(autocompleteInput, { types: ['geocode'] });

  // Añadir un listener para el evento 'place_changed' en la instancia de Autocomplete.
  // Este evento se dispara cuando el usuario selecciona una dirección sugerida del menú desplegable.
  ac.addListener('place_changed', () => {
    const place = ac.getPlace(); // Obtener el objeto PlaceResult para el lugar seleccionado.
    const wasHomePosSet = !!homePos; // Booleano: ¿Estaba homePos previamente establecido (no era null)?

    // Actualizar el estado global 'homePos' con las coordenadas del lugar seleccionado.
    // Si el lugar tiene datos de geometría, extraer lat/lng. De lo contrario, establecer homePos a null.
    homePos = place.geometry ? { lat: place.geometry.location.lat(), lng: place.geometry.location.lng() } : null;

    // Lógica para manejar casos donde la entrada de dirección de casa se borra o se vuelve inválida:
    if (!homePos && wasHomePosSet) { // Si homePos es ahora null Y estaba previamente establecido (es decir, se acaba de borrar)
      document.getElementById('nearest').textContent = ''; // Limpiar cualquier mensaje previo de "célula más cercana".
      
      // Revertir el encabezado de la columna 'DIRECCION' en la DataTable a su estado inicial.
      const direccionOriginalHeaderKey = 'DIRECCION'; // La clave de datos para la columna de dirección/ETA.
      const direccionColumnIndex = headES.indexOf(direccionOriginalHeaderKey); // Encontrar el índice de la columna.
      if (direccionColumnIndex !== -1 && table) { // Si la columna existe y la tabla está inicializada.
        const column = table.column(direccionColumnIndex); // Obtener el objeto de columna de DataTables.
        $(column.header()).html('CONDUCIR DESDE LA IGLESIA'); // Actualizar el texto del encabezado usando jQuery.
      }
      
      // Refrescar los datos mostrados en la tabla y las tarjetas.
      // Como homePos es ahora null, filterAndDisplayCells usará los ETAs por defecto (desde la iglesia)
      // o el texto especial para la zona "La Cosecha".
      filterAndDisplayCells(); 
    }
    // Si homePos se establece de nuevo (el usuario seleccionó una dirección válida), la búsqueda real y los cálculos de ETA
    // se activan mediante la función 'runSearch' (a través del clic del botón o la tecla Enter).
    // 'runSearch' se encargará entonces de actualizar el encabezado de la columna a "conduce desde tu casa".
  });

  // Añadir un listener de evento de clic al botón de búsqueda.
  document.getElementById('searchBtn').addEventListener('click', runSearch);

  // Añadir un listener de evento de pulsación de tecla al campo de entrada de dirección de casa.
  // Esto permite al usuario iniciar una búsqueda presionando la tecla 'Enter'.
  autocompleteInput.addEventListener('keypress', function(event) {
    if (event.key === 'Enter') { // Comprobar si la tecla presionada fue 'Enter'.
      event.preventDefault(); // Prevenir cualquier acción por defecto del navegador para 'Enter' (ej., envío de formulario).
      runSearch(); // Llamar a la función principal de búsqueda.
    }
  });
}

/* ---------- PROCESAMIENTO DE DATOS DE EXCEL ---------- */
// Esta función asíncrona obtiene 'celulas.xlsx', lee su contenido,
// procesa los datos para cada célula y calcula los ETAs iniciales desde la iglesia.
async function loadSheet() {
  try {
    // Obtener el archivo Excel del servidor.
    const response = await fetch('celulas.xlsx');
    // Obtener el contenido del archivo como un ArrayBuffer.
    const arrayBuffer = await response.arrayBuffer();
    // Analizar el ArrayBuffer en un objeto workbook usando SheetJS (biblioteca XLSX).
    const workbook = XLSX.read(arrayBuffer, { type: 'array' });

    // Determinar el nombre de la hoja a usar: preferentemente 'Consolidado', de lo contrario la primera hoja.
    const sheetName = workbook.Sheets['Consolidado'] ? 'Consolidado' : workbook.SheetNames[0];
    const sheet = workbook.Sheets[sheetName]; // Obtener el objeto de la hoja.
    
    // Convertir los datos de la hoja en un array de arrays (filas y columnas).
    // 'header: 1' significa que la primera fila se trata como datos (para extracción de encabezados).
    // 'defval: ''' asegura que las celdas vacías se representen como cadenas vacías.
    const sheetDataArray = XLSX.utils.sheet_to_json(sheet, { header: 1, defval: '' });
    
    // Extraer la primera fila como encabezados. Recortar espacios en blanco de cada encabezado.
    headES = sheetDataArray[0].map(h => String(h).trim());

    // Procesar las filas de datos subsiguientes (datos de las células).
    rows = sheetDataArray.slice(1) // Obtener todas las filas excepto la primera (fila de encabezado).
             .filter(rowArray => rowArray.some(cellValue => cellValue !== '')) // Filtrar filas que están completamente vacías.
             .map(rowArray => { // Transformar cada fila (que es un array de valores) en un objeto.
               const rowObject = {};
               // Usar los encabezados extraídos ('headES') como claves para las propiedades del objeto.
               headES.forEach((header, index) => rowObject[header] = rowArray[index]);
               return rowObject;
             })
             .filter(rowObject => { // Filtrar células según la columna 'IDIOMA'.
               const language = String(rowObject['IDIOMA']).toLowerCase(); // Obtener idioma, convertir a minúsculas.
               return language === 'español' || language === 'bilingüe'; // Mantener solo células en Español o Bilingües.
             });

    // Procesar de forma asíncrona cada objeto de fila para añadir propiedades de ETA calculadas.
    await Promise.all(rows.map(async (o) => { // 'o' representa un solo objeto de datos de célula.
      // Almacenar la cadena de dirección original de la columna "DIRECCION" de Excel.
      // o['DIRECCION'] actualmente contiene esta cadena. La guardaremos.
      o['DIRECCION_FROM_EXCEL'] = o['DIRECCION']; 

      let effectiveAddressForRouting; // Esta será la dirección usada para los cálculos de ETA.
      // Manejo especial para células en la zona "La Cosecha".
      if (o['ZONA'] === 'La Cosecha') {
        // Para la zona "La Cosecha", todos los cálculos de ETA usan la dirección principal de la iglesia (HUB_ADDR).
        effectiveAddressForRouting = HUB_ADDR;
      } else {
        // Para todas las demás zonas, usar su propia dirección tal como se leyó de la hoja de Excel.
        effectiveAddressForRouting = o['DIRECCION_FROM_EXCEL'];
      }
      // Almacenar esta dirección determinada en el objeto de la célula para su uso posterior en cálculos de ETA.
      o['EFFECTIVE_ROUTING_ADDRESS'] = effectiveAddressForRouting;

      // Calcular el ETA inicial desde la Iglesia (HUB_ADDR) hasta la dirección efectiva de esta célula.
      // Para la zona "La Cosecha", esto significará calcular el ETA desde HUB_ADDR hasta HUB_ADDR (lo que debería ser ~0 minutos).
      const etaHub = await driveMinutes(HUB_ADDR, o['EFFECTIVE_ROUTING_ADDRESS']);
      o['ETA_FROM_HUB'] = etaHub; // Almacenar el ETA numérico (en minutos) o null si el cálculo falló.

      // Inicializar la propiedad para almacenar el ETA desde la dirección de casa del usuario.
      o['ETA_FROM_HOME'] = null; // Será llenado por runSearch().

      // Nota Importante: Ya no establecemos o['DIRECCION'] a una cadena de ETA formateada aquí.
      // La función filterAndDisplayCells() será ahora la única responsable de construir la cadena
      // de visualización para la columna 'DIRECCION' dinámicamente según el contexto (búsqueda de casa o por defecto).
      // o['DIRECCION'] conservará su valor original de Excel hasta la visualización.
    }));

    // Después de que todos los datos se cargan y procesan, construir los componentes principales de la interfaz de usuario.
    buildUI();
  } catch(e) {
    // Si ocurre algún error durante la carga o el procesamiento, mostrarlo en el div de error.
    $('#error').show().text("Error cargando los datos de las células: " + e.message);
    console.error("Error in loadSheet:", e); // También registrar en la consola para depuración.
  }
}

/* ---------- CONSTRUCCIÓN DE LA INTERFAZ DE USUARIO (UI CONSTRUCTION) ---------- */
// Esta función inicializa la DataTable, llena el filtro de zona y configura los listeners de eventos.
function buildUI() {
  // Llenar el menú desplegable del filtro 'Zona'.
  // 1. Obtener todos los valores de 'ZONA' de los datos de 'rows'.
  // 2. Filtrar cualquier valor de zona vacío o nulo.
  // 3. Crear un Set para obtener nombres de zona únicos.
  // 4. Convertir el Set de nuevo a un array y ordenarlo alfabéticamente.
  // 5. Para cada zona única, añadir un elemento <option> al menú desplegable '#zonaSelect'.
  [...new Set(rows.map(r => r['ZONA']).filter(Boolean))].sort()
    .forEach(zone => $('#zonaSelect').append(`<option value="${zone}">${zone}</option>`));

  // Obtener los índices de las columnas '#' y 'ZONA' del array 'headES'.
  // Se usan para establecer el orden de clasificación por defecto en la DataTable.
  const numIdx = headES.indexOf('#'); 
  const zonaIdx = headES.indexOf('ZONA'); 
  // Definir la clave original de los datos de Excel para la columna 'DIRECCION'.
  // Se usa al mapear columnas y establecer el título inicial.
  const direccionOriginalHeaderKey = 'DIRECCION'; 

  // Inicializar la DataTable en el elemento HTML '#tabla'.
  table = $('#tabla').DataTable({
    // Definir columnas para la DataTable.
    columns: headES.map(originalHeaderName => { // Iterar sobre cada encabezado de 'headES'.
      let displayTitle = originalHeaderName; // El título de visualización por defecto es el nombre original del encabezado.
      // Si esta es la columna 'DIRECCION', establecer su título de visualización inicial.
      if (originalHeaderName === direccionOriginalHeaderKey) {
        displayTitle = 'CONDUCIR DESDE LA IGLESIA'; // Título inicial antes de cualquier búsqueda de casa.
      }
      // Para cada columna, devolver un objeto especificando su 'title' (encabezado mostrado)
      // y 'data' (el nombre de la propiedad en los objetos de fila de donde obtener los datos).
      return { title: displayTitle, data: originalHeaderName };
    }),
    // Establecer el orden de clasificación por defecto: por columna '#' ascendente, luego por columna 'ZONA' ascendente.
    // Se aplica solo si ambas columnas se encuentran.
    order: (numIdx !== -1 && zonaIdx !== -1) ? [[numIdx, 'asc'], [zonaIdx, 'asc']] : [], 
    pageLength: 10 // Mostrar 10 filas por página por defecto.
  });
  // Obtener una referencia al elemento DOM donde se renderizarán las tarjetas (para vista móvil).
  cardsDiv = document.getElementById('cards');
  
  // Realizar la población inicial de la DataTable y las tarjetas con los datos de las células procesados.
  filterAndDisplayCells(); 

  // Añadir un listener de evento al menú desplegable del filtro 'Zona'.
  // Cuando la zona seleccionada cambie, llamar a filterAndDisplayCells para actualizar la vista.
  $('#zonaSelect').on('change', function() {
    filterAndDisplayCells(); 
  });
}

/* ---------- FILTRADO Y VISUALIZACIÓN DE CÉLULAS (CELL FILTERING AND DISPLAY) ---------- */
// Esta función es responsable de:
// 1. Filtrar los datos de 'rows' según la zona seleccionada.
// 2. Preparar los datos para la visualización (estableciendo dinámicamente el campo 'DIRECCION').
// 3. Actualizar la DataTable y la vista de tarjetas con los datos filtrados/preparados.
function filterAndDisplayCells() {
  const selectedZone = $('#zonaSelect').val(); // Obtener el valor de la zona actualmente seleccionada.
  // Filtrar el array global 'rows'.
  // Si 'selectedZone' tiene un valor (no es una cadena vacía), filtrar por esa zona.
  // De lo contrario (si se selecciona "— Todas —", el valor es ""), usar todas las filas.
  // Se usa una copia superficial `[...rows]` para el caso "todas las zonas" para evitar riesgos de modificación directa.
  let currentFilteredRows = selectedZone ? rows.filter(r => r['ZONA'] === selectedZone) : [...rows]; 

  // Mapear sobre 'currentFilteredRows' para crear una 'displayList'.
  // Cada ítem en 'displayList' es un objeto 'cellForDisplay', que es una copia de los datos de una célula
  // pero con la propiedad 'DIRECCION' específicamente formateada para la visualización.
  const displayList = currentFilteredRows.map(cell => {
    const cellForDisplay = {...cell}; // Crear una copia superficial de los datos de la célula para modificarla para visualización.

    // Lógica para determinar el contenido de la columna 'DIRECCION' para esta célula:
    if (homePos && typeof cell.ETA_FROM_HOME === 'number') { 
      // CASO 1: Se ha realizado una búsqueda de dirección de casa exitosa (homePos está establecido)
      // Y existe un ETA numérico válido desde casa para esta célula en particular.
      // Mostrar el ETA desde la casa del usuario.
      // Esto también se aplica a las células de la zona "La Cosecha", mostrando el ETA desde casa hasta la iglesia.
      cellForDisplay['DIRECCION'] = `≈ ${cell.ETA_FROM_HOME} min`;
    } else { 
      // CASO 2: Escenario de fallback - No se ha realizado búsqueda de casa, o el ETA desde casa no está disponible para esta célula.
      if (cell['ZONA'] === 'La Cosecha') {
        // Para células en la zona "La Cosecha", mostrar el texto estático especial.
        cellForDisplay['DIRECCION'] = 'Planta baja de la Iglesia (reunion general)';
      } else {
        // Para células en otras zonas, mostrar su ETA desde el Hub (iglesia).
        // Si 'ETA_FROM_HUB' es null (ej., dirección no enrutable desde el hub), mostrar '—'.
        cellForDisplay['DIRECCION'] = cell.ETA_FROM_HUB != null ? `≈ ${cell.ETA_FROM_HUB} min` : '—';
      }
    }
    return cellForDisplay; // Devolver el objeto preparado para visualización.
  });

  // Si la instancia de DataTable ('table') ha sido inicializada:
  if (table) { 
    table.clear(); // Eliminar todas las filas existentes de la tabla.
    table.rows.add(displayList); // Añadir los nuevos datos de 'displayList'.
    table.draw(); // Redibujar la tabla para reflejar los cambios.
  }
  // Si el div contenedor de tarjetas ('cardsDiv') existe:
  if (cardsDiv) { 
    renderCards(displayList); // Renderizar/actualizar la vista de tarjetas con los datos de 'displayList'.
  }
}


/* ---------- RENDERIZADO DE TARJETAS (CARD RENDERING) ---------- */
// Genera HTML para tarjetas individuales (para vista móvil) basado en la lista de datos de células proporcionada.
function renderCards(list) {
  // 'list' aquí es 'displayList' de filterAndDisplayCells, donde cada objeto
  // (representando una célula) tiene su propiedad 'DIRECCION' ya formateada para visualización.
  cardsDiv.innerHTML = list.map(cellObject => { // Para cada célula en la lista...
    // Crear elementos de párrafo HTML para cada dato en la célula.
    // Itera sobre 'headES' (encabezados originales) y los usa para acceder a las propiedades de 'cellObject'.
    const lines = headES.map(header => `<p><strong>${header}:</strong> ${cellObject[header]}</p>`).join('');
    // Envolver estas líneas en un 'div' con la clase 'card'.
    return `<div class="card">${lines}</div>`;
  }).join(''); // Unir todas las cadenas HTML de las tarjetas en una gran cadena y establecerla como innerHTML.
}

/* ---------- UTILIDADES DE GEOCODIFICACIÓN Y ETA (GEOCODING AND ETA UTILITIES) ---------- */
// Función auxiliar asíncrona para obtener coordenadas geográficas ({lat, lng}) para una locationInput dada.
// 'locationInput' puede ser una cadena de dirección o un objeto {lat, lng} ya formado.
// Implementa caché para cadenas de dirección para reducir llamadas API.
async function getCoords(locationInput) {
  if (typeof locationInput === 'string') { // Si la entrada es una cadena de dirección.
    if (geoCache.has(locationInput)) return geoCache.get(locationInput); // Comprobar caché primero.
    // Si no está en caché, realizar geocodificación usando Google Maps Geocoder.
    return new Promise(resolve => { // Devolver una Promesa ya que la geocodificación es asíncrona.
      geocoder.geocode({ address: locationInput }, (results, status) => {
        let loc = null;
        if (status === 'OK' && results && results[0]) { // Si la geocodificación es exitosa.
          loc = { // Extraer latitud y longitud.
            lat: results[0].geometry.location.lat(), 
            lng: results[0].geometry.location.lng() 
          };
        } else {
          // Advertir en consola si la geocodificación falla.
          console.warn(`La geocodificación falló para la dirección "${locationInput}": ${status}`);
        }
        geoCache.set(locationInput, loc); // Almacenar el resultado (o null si falló) en la caché.
        resolve(loc); // Resolver la Promesa con el objeto de ubicación o null.
      });
    });
  } else if (locationInput && typeof locationInput.lat === 'number' && typeof locationInput.lng === 'number') {
    // Si la entrada ya es un objeto {lat, lng}, devolverlo directamente.
    return locationInput; 
  }
  // Si la entrada no es ni una cadena ni un objeto {lat, lng} válido.
  console.warn("Entrada de ubicación inválida para getCoords:", locationInput);
  return null; 
}

// 'gc' puede usarse como un alias más corto para 'getCoords' si se prefiere.
const gc = addr => getCoords(addr); 

// Calcula de forma asíncrona el tiempo de conducción en minutos entre un origen y un destino.
// 'originInput' y 'destinationInput' pueden ser cadenas de dirección u objetos {lat, lng}.
async function driveMinutes(originInput, destinationInput) {
  // Obtener los objetos de coordenadas para el origen y el destino.
  const oCoords = await getCoords(originInput);
  const dCoords = await getCoords(destinationInput);
  
  // Si no se pudieron determinar las coordenadas para el origen o el destino, devolver null (no se puede calcular ETA).
  if (!oCoords || !dCoords) return null;

  // Devolver una Promesa ya que la llamada al servicio Distance Matrix es asíncrona.
  return new Promise(resolve => {
    distSvc.getDistanceMatrix({
      origins: [new google.maps.LatLng(oCoords.lat, oCoords.lng)], // Origen, como objeto LatLng.
      destinations: [new google.maps.LatLng(dCoords.lat, dCoords.lng)], // Destino, como objeto LatLng.
      travelMode: 'DRIVING', // Especificar modo de conducción.
      drivingOptions: { 
        departureTime: new Date() // Usar hora actual para la salida para obtener ETAs dependientes del tráfico.
      } 
    }, (matrixResult, status) => { // Función callback para el servicio Distance Matrix.
      const element = matrixResult?.rows[0].elements[0]; // Obtener el elemento de resultado específico.
      // Comprobar si el estado general y el estado del elemento son 'OK'.
      if (status === 'OK' && element?.status === 'OK') {
        // Extraer duración. Priorizar 'duration_in_traffic' si está disponible, de lo contrario usar 'duration'.
        // El valor está en segundos, así que convertir a minutos y redondear.
        const durationInMinutes = Math.round((element.duration_in_traffic || element.duration).value / 60);
        resolve(durationInMinutes);
      } else {
        // Advertir en consola si falla el cálculo de la matriz de distancia.
        console.warn(`DistanceMatrix falló entre ${JSON.stringify(oCoords)} y ${JSON.stringify(dCoords)}: ${status}, estado del elemento: ${element?.status}`);
        resolve(null); // Devolver null si el cálculo de ETA falló por cualquier motivo.
      }
    });
  });
}

/* ---------- LÓGICA DE BÚSQUEDA DEL USUARIO ---------- */
// Esta función asíncrona se activa cuando el usuario inicia una búsqueda de células cercanas a su dirección de casa.
async function runSearch() {
  const rawHomeAddress = document.getElementById('homeInput').value.trim(); // Obtener dirección recortada de la entrada.
  const outNearestDiv = document.getElementById('nearest'); // Elemento DOM para el mensaje de "célula más cercana".
  const searchButton = document.getElementById('searchBtn'); // El botón de búsqueda.
  
  // --- Validación de Entrada y Geocodificación ---
  if (!rawHomeAddress) { // Si la entrada de dirección está vacía.
    outNearestDiv.textContent = 'Por favor, ingrese una dirección de casa.';
    return; // Salir de la función.
  }
  // Si 'homePos' (coordenadas globales) no está establecido PERO hay una cadena de dirección cruda presente
  // (ej., usuario escribió y presionó Enter sin seleccionar una sugerencia de Autocompletar),
  // intentar geocodificar la cadena de dirección cruda ahora.
  if (!homePos && rawHomeAddress) { 
      const loc = await getCoords(rawHomeAddress); // Geocodificar la dirección escrita.
      if (!loc) { // Si la geocodificación falla para la dirección escrita.
          outNearestDiv.textContent = 'Error: No se pudo geocodificar la dirección de casa ingresada.';
          return; // Salir de la función.
      }
      homePos = loc; // Actualizar 'homePos' global con las coordenadas geocodificadas.
  }
  // Si, después de todas las comprobaciones, 'homePos' sigue sin ser válido (null).
  if (!homePos) { 
    outNearestDiv.textContent = 'Error: Dirección de casa no válida o no seleccionada.';
    return; // Salir de la función.
  }

  // --- Actualizaciones de UI para Inicio de Búsqueda ---
  searchButton.disabled = true; // Deshabilitar el botón de búsqueda durante el procesamiento.
  outNearestDiv.textContent = 'Buscando células cercanas…'; // Actualizar mensaje para indicar búsqueda.

  try {
    // --- Calcular ETAs desde Casa ---
    // Crear un array de Promesas, una para cada célula, para calcular el ETA desde la casa del usuario.
    const promises = rows.map(async (cell) => { 
      // Usar la 'EFFECTIVE_ROUTING_ADDRESS' de la célula para el destino.
      // Para células de la zona "La Cosecha", esto será HUB_ADDR (la dirección de la iglesia).
      // Para otras células, es su propia dirección de la hoja de Excel.
      const eta = await driveMinutes(homePos, cell['EFFECTIVE_ROUTING_ADDRESS']);
      // Actualizar la propiedad 'ETA_FROM_HOME' en el objeto de la célula en el array 'rows'.
      cell.ETA_FROM_HOME = eta; 
      return cell; // No es estrictamente necesario devolver cell aquí, ya que 'rows' se modifica directamente.
    });
    await Promise.all(promises); // Esperar a que todos los cálculos asíncronos de ETA se completen.

    // --- Actualizar Encabezado de Columna ---
    // Ahora que los ETAs desde casa han sido procesados (o intentados),
    // actualizar el encabezado de la columna "DIRECCION" para reflejar que los ETAs son desde la casa del usuario.
    const direccionOriginalHeaderKey = 'DIRECCION';
    const direccionColumnIndex = headES.indexOf(direccionOriginalHeaderKey);
    if (direccionColumnIndex !== -1 && table) {
      const column = table.column(direccionColumnIndex);
      $(column.header()).html('CONDUCIR DESDE TU CASA'); // Establecer nuevo texto del encabezado.
    }

    // --- Encontrar y Mostrar Células Más Cercanas ---
    // Crear un nuevo array de datos de células (copias superficiales) para ordenar, para que el array 'rows' no se reordene.
    let cellsWithEta = rows.map(cell => ({...cell})); 
    // Ordenar este array por 'ETA_FROM_HOME' en orden ascendente.
    // Las células donde 'ETA_FROM_HOME' es null (cálculo fallido) se empujan al final.
    cellsWithEta.sort((a, b) => {
      if (a.ETA_FROM_HOME === null && b.ETA_FROM_HOME === null) return 0; // Ambos null, iguales.
      if (a.ETA_FROM_HOME === null) return 1;  // 'a' (null) es mayor (viene después) que 'b' (no null).
      if (b.ETA_FROM_HOME === null) return -1; // 'b' (null) es mayor (viene después) que 'a' (no null).
      return a.ETA_FROM_HOME - b.ETA_FROM_HOME; // Comparación numérica estándar.
    });

    // Obtener las 3 primeras células de la lista ordenada que tienen un ETA desde casa válido (no null).
    const nearestThree = cellsWithEta.filter(c => c.ETA_FROM_HOME !== null).slice(0, 3);

    // --- Mostrar Resultados ---
    if (nearestThree.length > 0) { // Si se encontró al menos una célula cercana.
      const nearestCell = nearestThree[0]; // La célula más cercana en absoluto.
      // Actualizar 'outNearestDiv' con información sobre la célula más cercana.
      // Asume que 'MAESTRO' y 'TELEFONO' son las claves correctas para maestro y teléfono de tus datos.
      outNearestDiv.textContent = `La célula más cercana (#${nearestCell['#']}) está a ≈ ${nearestCell.ETA_FROM_HOME} min. ` +
                        `Maestro/a: ${nearestCell['MAESTRO']}, ` +
                        `Tel: ${nearestCell['TELEFONO']}.`;
      
      // Preparar estas 3 células más cercanas para mostrar en la DataTable y las tarjetas.
      // Su campo 'DIRECCION' necesita ser establecido explícitamente para mostrar el ETA desde casa.
      const displayDataNearestThree = nearestThree.map(cell => {
        const displayCell = {...cell}; // Crear una copia para visualización.
        // Establecer la propiedad 'DIRECCION' a la cadena de ETA desde casa formateada.
        displayCell['DIRECCION'] = `≈ ${cell.ETA_FROM_HOME} min`; 
        return displayCell;
      });

      // Actualizar la DataTable: limpiar filas existentes, añadir las 3 más cercanas y redibujar.
      table.clear().rows.add(displayDataNearestThree).draw();
      // Actualizar la vista de tarjetas con las 3 células más cercanas.
      renderCards(displayDataNearestThree);
    } else { // Si no se encontraron células cercanas con ETAs válidos.
      outNearestDiv.textContent = 'No se encontraron células cercanas o no se pudo calcular el tiempo de viaje.';
    }

  } catch(e) { // Capturar cualquier error que ocurra durante el proceso de búsqueda y cálculo de ETA.
    outNearestDiv.textContent = 'Error durante la búsqueda: ' + e.message;
    console.error("Error in runSearch:", e); // Registrar error detallado en la consola.
  } finally { // Este bloque se ejecuta independientemente de si ocurrió un error o no.
    searchButton.disabled = false; // Siempre volver a habilitar el botón de búsqueda.
  }
}
</script>
</body>
</html>
