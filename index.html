<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8"/>
<title>Células de Crecimiento | Zona</title>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<link rel="stylesheet"
      href="https://cdn.datatables.net/1.13.8/css/jquery.dataTables.min.css"/>
<style>
/* -------- estilos: idénticos a los que ya usas -------- */
body{font-family:system-ui,Arial,sans-serif;margin:0;background:#fafafa}

header .banner{display:block;width:100%;height:auto;max-height:25vh;object-fit:contain;margin:0}

.controls{margin:1rem 2rem;display:flex;flex-wrap:wrap;gap:.75rem;align-items:center}
#zonaSelect,#homeInput{padding:.35rem .6rem;font-size:1rem;border:1px solid #ccc;border-radius:4px}
#homeInput{min-width:260px;flex:1 1 260px}
#homeInput::placeholder{color:#999}
#searchBtn{padding:.35rem .9rem;font-size:1rem;border:1px solid #2d57a3;background:#2d57a3;color:#fff;border-radius:4px;cursor:pointer}
#searchBtn:disabled{opacity:.5;cursor:not-allowed}

.table-wrapper{height:65vh;overflow:auto;padding:0 2rem 1.5rem}
table.dataTable{border:2px solid #13284b;border-collapse:collapse;width:100%;table-layout:fixed}
table.dataTable thead th{background:#2d57a3;color:#fff;border:1px solid #13284b;font-weight:700;text-align:center}
table.dataTable td{border:1px solid #ccc;padding:6px 4px;word-wrap:break-word}
table.dataTable tbody td:nth-child(1){background:#eee;font-weight:700;text-align:center}
table.dataTable tbody tr:nth-child(even) td{background:#f8f8f8}

.cards{display:none;padding:0 1rem 2rem;overflow:auto;height:65vh}
.card{border:1px solid #ccc;border-radius:6px;margin-bottom:1rem;padding:1rem;background:#fff;box-shadow:0 1px 3px rgba(0,0,0,.05)}
.card p{margin:.25rem 0;font-size:.95rem}

@media(max-width:900px){
  .table-wrapper{display:none}
  .cards{display:block}
  .controls{margin:1rem}
}

#nearest{margin:.5rem 2rem 0;font-weight:600}
#error{color:#c00;margin:1rem 2rem 0;font-weight:700}
</style>
</head>
<body>
<header>
  <img src="./header.svg" class="banner" alt="La Cosecha – Células">
</header>

<div class="controls">
  <label for="zonaSelect"><strong>Zona:</strong></label>
  <select id="zonaSelect"><option value="">— Todas —</option></select>

  <label for="homeInput" class="addr-label">Buscar dirección más cercana:</label>
  <input id="homeInput" type="text" placeholder="Dirección de casa"/>
  <button id="searchBtn">Buscar</button>
</div>

<div id="nearest"></div>

<div class="table-wrapper"><table id="tabla" class="display"></table></div>
<div id="cards"  class="cards"></div>
<div id="error"  hidden></div>

<script src="./xlsx.full.min.js"></script> <script src="https://code.jquery.com/jquery-3.7.1.min.js"></script> <script src="https://cdn.datatables.net/1.13.8/js/jquery.dataTables.min.js"></script> <script async defer
  src="https://maps.googleapis.com/maps/api/js?key=AIzaSyC4LU0O02a7lCRtZeyGbigQQcJ4EuSKa7A&libraries=places&callback=gmapsReady">
</script>

<script>
/* ---------- CONSTANTES (CONSTANTS) ---------- */
// HUB_ADDR: The fixed address of the church. Used as the origin for initial ETA calculations.
const HUB_ADDR = '600 Greenwich St, Hempstead, NY 11550';

/* ---------- ESTADO GLOBAL (GLOBAL STATE) ---------- */
// headES: Array to store the headers from the Excel sheet.
let headES = [];
// rows: Array to store the data for each cell (bible study group), processed from the Excel sheet.
let rows = [];
// table: Variable to hold the DataTables instance.
let table;
// cardsDiv: DOM element where cards for mobile view will be rendered.
let cardsDiv;
// geocoder: Google Maps Geocoder instance, used to convert addresses to coordinates.
let geocoder;
// distSvc: Google Maps DistanceMatrixService instance, used to calculate travel times.
let distSvc;
// homePos: Object to store the latitude and longitude of the user's input home address. Null if not set.
let homePos = null;
// geoCache: A Map to cache geocoding results (address -> {lat, lng}) to avoid redundant API calls.
const geoCache = new Map();

/* ---------- GOOGLE MAPS LISTO (GOOGLE MAPS READY) ---------- */
// This function is called once the Google Maps API script has loaded and is ready.
async function gmapsReady() {
  // Initialize Google Maps services.
  geocoder = new google.maps.Geocoder();
  distSvc = new google.maps.DistanceMatrixService();
  
  // Load data from the Excel sheet and build the initial UI.
  await loadSheet();

  // Initialize Google Places Autocomplete for the home address input field.
  const autocompleteInput = document.getElementById('homeInput');
  const ac = new google.maps.places.Autocomplete(autocompleteInput, { types: ['geocode'] });

  // Listen for the 'place_changed' event from the Autocomplete instance.
  // This event fires when the user selects an address from the Autocomplete suggestions.
  ac.addListener('place_changed', () => {
    const place = ac.getPlace(); // Get the PlaceResult object.
    const wasHomePosSet = !!homePos; // Check if homePos had a value before this change.

    // Update homePos with the new coordinates if a valid place is selected.
    homePos = place.geometry ? { lat: place.geometry.location.lat(), lng: place.geometry.location.lng() } : null;

    // If homePos becomes null (e.g., user cleared the input) AND it was previously set:
    if (!homePos && wasHomePosSet) {
      document.getElementById('nearest').textContent = ''; // Clear the "nearest cell" message.
      
      // Revert the "DIRECCION" column header back to its original state (ETA from church).
      const direccionOriginalHeaderKey = 'DIRECCION';
      const direccionColumnIndex = headES.indexOf(direccionOriginalHeaderKey);
      if (direccionColumnIndex !== -1 && table) {
        const column = table.column(direccionColumnIndex);
        $(column.header()).html('conducir desde la iglesia'); // Update header text using jQuery.
      }
      
      // Re-render the table and cards. Since homePos is now null,
      // filterAndDisplayCells will show ETAs from the church.
      filterAndDisplayCells(); 
    }
    // If homePos is newly set or changed to another valid location, the 'runSearch' function 
    // (triggered by button click or Enter key) will handle updating the header and ETAs.
  });

  // Add event listener to the search button to trigger runSearch on click.
  document.getElementById('searchBtn').addEventListener('click', runSearch);

  // Add event listener to the home address input field to trigger runSearch on 'Enter' key press.
  autocompleteInput.addEventListener('keypress', function(event) {
    if (event.key === 'Enter') {
      event.preventDefault(); // Prevent default form submission behavior if any.
      runSearch(); // Execute the search.
    }
  });
}

/* ---------- LEE EXCEL, FILTRA Y REEMPLAZA DIRECCIÓN POR ETA (READ EXCEL, FILTER, AND REPLACE ADDRESS WITH ETA) ---------- */
// This function fetches the Excel file, parses its content, calculates initial ETAs from the church, and prepares data.
async function loadSheet() {
  try {
    // Fetch the Excel file.
    const response = await fetch('celulas.xlsx');
    const arrayBuffer = await response.arrayBuffer();
    const workbook = XLSX.read(arrayBuffer, { type: 'array' });

    // Get the 'Consolidado' sheet or the first sheet if 'Consolidado' is not found.
    const sheetName = workbook.Sheets['Consolidado'] ? 'Consolidado' : workbook.SheetNames[0];
    const sheet = workbook.Sheets[sheetName];
    
    // Convert sheet data to a JSON array (array of arrays).
    const sheetDataArray = XLSX.utils.sheet_to_json(sheet, { header: 1, defval: '' });
    
    // Extract headers (first row) and trim them.
    headES = sheetDataArray[0].map(h => String(h).trim());

    // Process data rows.
    rows = sheetDataArray.slice(1) // Skip header row.
             .filter(rowArray => rowArray.some(cellValue => cellValue !== '')) // Filter out completely empty rows.
             .map(rowArray => { // Convert each row array to an object using headers as keys.
               const rowObject = {};
               headES.forEach((header, index) => rowObject[header] = rowArray[index]);
               return rowObject;
             })
             .filter(rowObject => { // Filter cells by language ('español' or 'bilingüe').
               const language = String(rowObject['IDIOMA']).toLowerCase();
               return language === 'español' || language === 'bilingüe';
             });

    // Asynchronously calculate ETA from each cell's address to the church (HUB_ADDR).
    await Promise.all(rows.map(async (rowObject) => {
      rowObject['DIRECCION_RAW'] = rowObject['DIRECCION']; // Store the original address.
      const etaHub = await driveMinutes(rowObject['DIRECCION_RAW'], HUB_ADDR); // Calculate ETA.
      rowObject['ETA_FROM_HUB'] = etaHub; // Store the numeric ETA from hub (or null).
      // Set the default display text for the 'DIRECCION' field (ETA from hub).
      rowObject['DIRECCION'] = etaHub != null ? `≈ ${etaHub} min` : '—'; 
      rowObject['ETA_FROM_HOME'] = null; // Initialize ETA from home as null.
    }));

    // Once data is processed, build the UI elements (DataTable, cards).
    buildUI();
  } catch(e) {
    // Display any errors encountered during loading/processing.
    $('#error').show().text("Error cargando los datos de las células: " + e.message);
    console.error("Error in loadSheet:", e);
  }
}

/* ---------- CONSTRUYE DATATABLE Y TARJETAS (BUILD DATATABLE AND CARDS) ---------- */
// This function initializes the DataTable and sets up dynamic parts of the UI.
function buildUI() {
  // Populate the 'Zona' (Zone) filter dropdown with unique, sorted zone values from the data.
  [...new Set(rows.map(r => r['ZONA']).filter(Boolean))].sort()
    .forEach(zone => $('#zonaSelect').append(`<option value="${zone}">${zone}</option>`));

  // Get indices of '#' and 'ZONA' columns for default sorting if they exist.
  const numIdx = headES.indexOf('#'); 
  const zonaIdx = headES.indexOf('ZONA'); 
  // The key for the address column in your data objects, used for initial title setup.
  const direccionOriginalHeaderKey = 'DIRECCION'; 

  // Initialize the DataTable.
  table = $('#tabla').DataTable({
    columns: headES.map(originalHeaderName => { // Map Excel headers to DataTable column definitions.
      let displayTitle = originalHeaderName;
      // If this is the 'DIRECCION' column, set its initial display title.
      if (originalHeaderName === direccionOriginalHeaderKey) {
        displayTitle = 'conducir desde la iglesia'; 
      }
      // 'data' property tells DataTables which field in the data object to use for this column.
      // 'title' property is the text displayed in the column header.
      return { title: displayTitle, data: originalHeaderName };
    }),
    // Default sorting order: by '#' then by 'ZONA', if these columns exist.
    order: (numIdx !== -1 && zonaIdx !== -1) ? [[numIdx, 'asc'], [zonaIdx, 'asc']] : [], 
    pageLength: 10 // Number of rows per page.
  });
  // Get the DOM element for rendering cards (for mobile view).
  cardsDiv = document.getElementById('cards');
  
  // Perform initial population of the table and cards.
  filterAndDisplayCells(); 

  // Add event listener to the 'Zona' filter dropdown.
  // When the selection changes, re-filter and re-display the cells.
  $('#zonaSelect').on('change', function() {
    filterAndDisplayCells(); 
  });
}

/* ---------- PREPARA DATOS Y ACTUALIZA DATATABLE Y TARJETAS (PREPARE DATA AND UPDATE DATATABLE AND CARDS) ---------- */
// This function filters rows based on the selected zone and updates the DataTable and cards.
// It also dynamically sets the 'DIRECCION' field based on whether a home search has been performed.
function filterAndDisplayCells() {
  const selectedZone = $('#zonaSelect').val(); // Get the currently selected zone.
  // Filter rows: if a zone is selected, use it; otherwise, use all rows.
  let currentFilteredRows = selectedZone ? rows.filter(r => r['ZONA'] === selectedZone) : [...rows]; 

  // Map over the filtered rows to prepare them for display.
  const displayList = currentFilteredRows.map(cell => {
    const cellForDisplay = {...cell}; // Create a shallow copy to avoid modifying original row objects directly.

    // If a home address has been searched (homePos is set) AND a valid ETA from home exists for this cell:
    if (homePos && typeof cell.ETA_FROM_HOME === 'number') { 
      // Set the 'DIRECCION' field to display the ETA from home.
      cellForDisplay['DIRECCION'] = `≈ ${cell.ETA_FROM_HOME} min`;
    } else {
      // Otherwise, display the ETA from the church (hub).
      cellForDisplay['DIRECCION'] = cell.ETA_FROM_HUB != null ? `≈ ${cell.ETA_FROM_HUB} min` : '—';
    }
    return cellForDisplay;
  });

  // If the DataTable instance exists, clear it and add the new list of cells, then redraw.
  if (table) { 
    table.clear().rows.add(displayList).draw();
  }
  // If the cards container exists, render the cards for the new list of cells.
  if (cardsDiv) { 
    renderCards(displayList);
  }
}

/* ---------- RENDER CARDS (TODAS LAS COLUMNAS) (RENDER CARDS - ALL COLUMNS) ---------- */
// This function generates HTML for cards (mobile view) based on the provided list of cells.
function renderCards(list) {
  // For each cell in the list, create a card with all its data.
  cardsDiv.innerHTML = list.map(cellObject => {
    // For each header, create a line: "Header: Value".
    const lines = headES.map(header => `<p><strong>${header}:</strong> ${cellObject[header]}</p>`).join('');
    return `<div class="card">${lines}</div>`;
  }).join('');
}

/* ---------- UTILIDADES GEOCODIFICACIÓN / ETA (GEOCODING / ETA UTILITIES) ---------- */
// Helper function to get coordinates ({lat, lng}) for a location input.
// Input can be an address string or an already formed {lat, lng} object.
// Uses a cache (geoCache) to store results for address strings.
async function getCoords(locationInput) {
  if (typeof locationInput === 'string') { // If input is an address string.
    if (geoCache.has(locationInput)) return geoCache.get(locationInput); // Check cache first.
    // If not in cache, use Google's Geocoder.
    return new Promise(resolve => {
      geocoder.geocode({ address: locationInput }, (results, status) => {
        const loc = status === 'OK' ? { lat: results[0].geometry.location.lat(), lng: results[0].geometry.location.lng() } : null;
        geoCache.set(locationInput, loc); // Store result (or null) in cache.
        resolve(loc);
      });
    });
  } else if (locationInput && typeof locationInput.lat === 'number' && typeof locationInput.lng === 'number') {
    // If input is already a {lat, lng} object, return it directly.
    return locationInput; 
  }
  // Log a warning and return null for invalid input types.
  console.warn("Invalid location input for getCoords:", locationInput);
  return null; 
}

// Alias for getCoords, can be used if 'gc' is preferred for brevity.
const gc = addr => getCoords(addr); 

// Calculates driving time in minutes between an origin and a destination.
// originInput and destinationInput can be address strings or {lat, lng} objects.
async function driveMinutes(originInput, destinationInput) {
  // Get coordinates for origin and destination.
  const oCoords = await getCoords(originInput);
  const dCoords = await getCoords(destinationInput);
  
  // If coordinates for either could not be found, return null.
  if (!oCoords || !dCoords) return null;

  // Use Google's Distance Matrix service.
  return new Promise(resolve => {
    distSvc.getDistanceMatrix({
      origins: [new google.maps.LatLng(oCoords.lat, oCoords.lng)],
      destinations: [new google.maps.LatLng(dCoords.lat, dCoords.lng)],
      travelMode: 'DRIVING',
      drivingOptions: { departureTime: new Date() } // Considers current traffic conditions.
    }, (matrixResult, status) => {
      const element = matrixResult?.rows[0].elements[0];
      // If status is OK and element status is OK, extract duration.
      if (status === 'OK' && element?.status === 'OK') {
        // Prioritize duration_in_traffic if available, otherwise use standard duration. Convert seconds to minutes.
        const durationInMinutes = Math.round((element.duration_in_traffic || element.duration).value / 60);
        resolve(durationInMinutes);
      } else {
        resolve(null); // Return null if ETA calculation fails.
      }
    });
  });
}

/* ---------- BÚSQUEDA DEL USUARIO (USER SEARCH) ---------- */
// This function is triggered when the user searches for their home address.
async function runSearch() {
  const rawHomeAddress = document.getElementById('homeInput').value.trim(); // Get raw address from input.
  const outNearestDiv = document.getElementById('nearest'); // Div to display nearest cell info.
  const searchButton = document.getElementById('searchBtn'); // Search button element.
  
  // Validate input: if address is empty, show message and exit.
  if (!rawHomeAddress) {
    outNearestDiv.textContent = 'Por favor, ingrese una dirección de casa.';
    return;
  }
  // If homePos is not yet set (e.g., user typed address and hit Enter without Autocomplete selection),
  // try to geocode the raw address string now.
  if (!homePos && rawHomeAddress) { 
      const loc = await getCoords(rawHomeAddress);
      if (!loc) { // If geocoding fails.
          outNearestDiv.textContent = 'Error: No se pudo geocodificar la dirección de casa ingresada.';
          return;
      }
      homePos = loc; // Set global homePos.
  }
  // If, after all attempts, homePos is still not valid, show error and exit.
  if (!homePos) { 
    outNearestDiv.textContent = 'Error: Dirección de casa no válida o no seleccionada.';
    return;
  }

  // Disable search button and show "searching" message during processing.
  searchButton.disabled = true; 
  outNearestDiv.textContent = 'Buscando células cercanas…';

  try {
    // Calculate ETAs from the user's home to ALL cells.
    // This updates the 'ETA_FROM_HOME' property in the main 'rows' array objects.
    const promises = rows.map(async (cell) => { 
      const eta = await driveMinutes(homePos, cell['DIRECCION_RAW']);
      cell.ETA_FROM_HOME = eta; 
      return cell; 
    });
    await Promise.all(promises); // Wait for all ETA calculations to complete.

    // OPTIONAL REFINEMENT IMPLEMENTED: Update "DIRECCION" column header to "conduce desde tu casa"
    // *after* ETAs from home have been calculated.
    const direccionOriginalHeaderKey = 'DIRECCION';
    const direccionColumnIndex = headES.indexOf(direccionOriginalHeaderKey);
    if (direccionColumnIndex !== -1 && table) {
      const column = table.column(direccionColumnIndex);
      $(column.header()).html('conduce desde tu casa'); 
    }

    // Create a temporary list of cells (shallow copies) to sort by ETA from home.
    let cellsWithEta = rows.map(cell => ({...cell})); 
    // Sort cells: by ETA_FROM_HOME ascending. Cells with null ETA (calculation failed) go to the end.
    cellsWithEta.sort((a, b) => {
      if (a.ETA_FROM_HOME === null && b.ETA_FROM_HOME === null) return 0;
      if (a.ETA_FROM_HOME === null) return 1; // 'a' (null) comes after 'b' (not null).
      if (b.ETA_FROM_HOME === null) return -1; // 'b' (null) comes after 'a' (not null).
      return a.ETA_FROM_HOME - b.ETA_FROM_HOME; // Standard numeric sort.
    });

    // Get the top 3 nearest cells that have a valid ETA from home.
    const nearestThree = cellsWithEta.filter(c => c.ETA_FROM_HOME !== null).slice(0, 3);

    if (nearestThree.length > 0) { // If at least one nearby cell is found.
      const nearestCell = nearestThree[0]; // The absolute nearest one.
      // Display message about the nearest cell, including teacher's name and phone.
      // Assumes 'MAESTRO' and 'TELEFONO' are the correct column names in your Excel.
      outNearestDiv.textContent = `La célula más cercana (#${nearestCell['#']}) está a ≈ ${nearestCell.ETA_FROM_HOME} min. ` +
                        `Maestro/a: ${nearestCell['MAESTRO']}, ` +
                        `Tel: ${nearestCell['TELEFONO']}.`;
      
      // Prepare these 3 nearest cells for display in table/cards.
      // Their 'DIRECCION' field will show ETA from home.
      const displayDataNearestThree = nearestThree.map(cell => {
        const displayCell = {...cell};
        displayCell['DIRECCION'] = `≈ ${cell.ETA_FROM_HOME} min`;
        return displayCell;
      });

      // Update DataTable and cards to show only these 3 nearest cells.
      table.clear().rows.add(displayDataNearestThree).draw();
      renderCards(displayDataNearestThree);
    } else { // If no cells found or ETAs couldn't be calculated.
      outNearestDiv.textContent = 'No se encontraron células cercanas o no se pudo calcular el tiempo de viaje.';
    }

  } catch(e) { // Catch any errors during the search process.
    outNearestDiv.textContent = 'Error durante la búsqueda: ' + e.message;
    console.error("Error in runSearch:", e);
  } finally { // Always re-enable the search button.
    searchButton.disabled = false;
  }
}
</script>
</body>
</html>
