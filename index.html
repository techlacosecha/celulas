<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8"/>
<title>Células de Crecimiento | Zona</title>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<link rel="stylesheet"
      href="https://cdn.datatables.net/1.13.8/css/jquery.dataTables.min.css"/>
<style>
/* -------- Estilos CSS -------- */
/* Estilos del body: Define la fuente por defecto para toda la página,
   elimina el margen exterior predeterminado del body y establece un color de fondo claro. */
body{font-family:system-ui,Arial,sans-serif;margin:0;background:#fafafa}

/* Estilos del banner del encabezado: Asegura que la imagen del banner
   ocupe todo el ancho disponible (display:block, width:100%),
   mantenga su proporción (height:auto), no exceda una altura máxima (max-height:25vh del alto del viewport),
   y que la imagen se escale para ajustarse dentro de sus límites sin ser recortada (object-fit:contain). */
header .banner{display:block;width:100%;height:auto;max-height:25vh;object-fit:contain;margin:0}

/* Estilos del contenedor de controles: Este div ('controls') contiene el filtro de zona y la búsqueda de dirección.
   Se utiliza flexbox para un diseño adaptable: 'display:flex' para habilitar flexbox,
   'flex-wrap:wrap' para que los elementos pasen a la siguiente línea si no caben,
   'gap' para espaciado entre elementos, y 'align-items:center' para alinearlos verticalmente. */
.controls{margin:1rem 2rem;display:flex;flex-wrap:wrap;gap:.75rem;align-items:center}
/* Estilos para el menú desplegable de selección de zona ('#zonaSelect') y la entrada de texto para la dirección ('#homeInput'):
   Define el relleno interno, tamaño de fuente, borde y radio de los bordes para una apariencia uniforme. */
#zonaSelect,#homeInput{padding:.35rem .6rem;font-size:1rem;border:1px solid #ccc;border-radius:4px}
/* Estilos específicos para la entrada de dirección de casa ('#homeInput'):
   'min-width' para asegurar que no sea demasiado pequeño, y propiedades flex ('flex:1 1 260px')
   para que crezca y se encoja de manera flexible dentro del contenedor 'controls', con una base de 260px. */
#homeInput{min-width:260px;flex:1 1 260px}
/* Color del texto del placeholder (ej., "Dirección de casa") para la entrada de dirección. */
#homeInput::placeholder{color:#999}
/* Estilos del botón de búsqueda ('#searchBtn'): Define su apariencia visual y comportamiento del cursor. */
#searchBtn{padding:.35rem .9rem;font-size:1rem;border:1px solid #2d57a3;background:#2d57a3;color:#fff;border-radius:4px;cursor:pointer}
/* Estilos para el botón de búsqueda cuando está en estado deshabilitado:
   'opacity:.5' lo hace semitransparente, y 'cursor:not-allowed' indica que no se puede hacer clic. */
#searchBtn:disabled{opacity:.5;cursor:not-allowed}

/* Estilos del contenedor de la tabla ('table-wrapper'):
   Altura fija (65% del alto del viewport), habilita una barra de desplazamiento vertical si el contenido excede esta altura ('overflow:auto'),
   y añade relleno horizontal. */
.table-wrapper{height:65vh;overflow:auto;padding:0 2rem 1.5rem}
/* Estilos base para la DataTable: Borde sólido, 'border-collapse:collapse' para que los bordes de las celdas se fusionen,
   'width:100%' para que ocupe todo el ancho de su contenedor, y 'table-layout:fixed' para un renderizado más predecible del ancho de las columnas. */
table.dataTable{border:2px solid #13284b;border-collapse:collapse;width:100%;table-layout:fixed}
/* Estilos para las celdas del encabezado (<thead><th>) de la DataTable: Fondo, color de texto, borde, grosor de fuente y alineación. */
table.dataTable thead th{background:#2d57a3;color:#fff;border:1px solid #13284b;font-weight:700;text-align:center}
/* Estilos para las celdas de datos (<td>) de la DataTable: Borde, relleno y 'word-wrap:break-word' para que el texto largo pase a la siguiente línea dentro de la celda. */
table.dataTable td{border:1px solid #ccc;padding:6px 4px;word-wrap:break-word}
/* Estilo para la primera celda (<td>) en cada fila del cuerpo (<tbody>) de la DataTable (usualmente la columna '#'):
   Un fondo diferente, texto en negrita y centrado para destacarla. */
table.dataTable tbody td:nth-child(1){background:#eee;font-weight:700;text-align:center}
/* Estilo de "cebreado" para las filas pares (even) en el cuerpo de la DataTable:
   Un fondo ligeramente diferente para mejorar la legibilidad de las filas. */
table.dataTable tbody tr:nth-child(even) td{background:#f8f8f8}

/* Estilos del contenedor de tarjetas ('cards'), usado para la vista en dispositivos móviles:
   'display:none' lo oculta por defecto. Se mostrará mediante media queries.
   Tiene relleno, permite desplazamiento si el contenido es muy alto, y una altura fija. */
.cards{display:none;padding:0 1rem 2rem;overflow:auto;height:65vh}
/* Estilos para cada tarjeta individual ('card'): Define su borde, esquinas redondeadas, margen, relleno, color de fondo y una ligera sombra. */
.card{border:1px solid #ccc;border-radius:6px;margin-bottom:1rem;padding:1rem;background:#fff;box-shadow:0 1px 3px rgba(0,0,0,.05)}
/* Estilos para los párrafos (<p>) dentro de cada tarjeta: Pequeño margen vertical y tamaño de fuente. */
.card p{margin:.25rem 0;font-size:.95rem}

/* Media query para pantallas con un ancho máximo de 900px (típicamente tabletas y móviles):
   Aquí se define el cambio de diseño para pantallas más pequeñas. */
@media(max-width:900px){
  .table-wrapper{display:none} /* Ocultar el contenedor de la tabla. */
  .cards{display:block}       /* Mostrar el contenedor de las tarjetas en su lugar. */
  .controls{margin:1rem}      /* Ajustar el margen del área de controles para pantallas pequeñas. */
}

/* Estilos para el div ('#nearest') que mostrará el mensaje sobre la célula más cercana encontrada. */
#nearest{margin:.5rem 2rem 0;font-weight:600}
/* Estilos para el div ('#error') que mostrará mensajes de error generales (ej., si falla la carga del Excel). */
#error{color:#c00;margin:1rem 2rem 0;font-weight:700}
</style>
</head>
<body>
<header>
  <img src="./header.svg" class="banner" alt="La Cosecha – Células">
</header>

<div class="controls">
  <label for="zonaSelect"><strong>Zona:</strong></label>
  <select id="zonaSelect"><option value="">— Todas —</option></select> <label for="homeInput" class="addr-label">Buscar dirección más cercana:</label>
  <input id="homeInput" type="text" placeholder="Dirección de casa"/> <button id="searchBtn">Buscar</button> </div>

<div id="nearest"></div>

<div class="table-wrapper"><table id="tabla" class="display"></table></div>
<div id="cards"  class="cards"></div>
<div id="error"  hidden></div>

<script src="./xlsx.full.min.js"></script> <script src="https://code.jquery.com/jquery-3.7.1.min.js"></script> <script src="https://cdn.datatables.net/1.13.8/js/jquery.dataTables.min.js"></script> <script async defer
  src="https://maps.googleapis.com/maps/api/js?key=AIzaSyC4LU0O02a7lCRtZeyGbigQQcJ4EuSKa7A&libraries=places&callback=gmapsReady">
</script>

<script>
/* ==========================================================================
   Lógica JavaScript para la Aplicación Buscador de Células
   ========================================================================== */

/* ---------- CONSTANTES GLOBALES ---------- */
// HUB_ADDR: Define la dirección física de la iglesia "La Cosecha".
// Esta constante se utiliza como:
// 1. El punto de origen para calcular el tiempo estimado de llegada (ETA) inicial a todas las células.
// 2. La dirección de destino específica para las células que pertenecen a la zona "La Cosecha",
//    asumiendo que estas se realizan en las instalaciones de la iglesia.
const HUB_ADDR = '600 Greenwich St, Hempstead, NY 11550';

/* ---------- ESTADO GLOBAL DE LA APLICACIÓN ---------- */
// headES: Un array que almacenará los nombres de los encabezados de las columnas.
// Estos nombres se extraen de la primera fila del archivo Excel procesado.
// Se utilizan para:
//   a) Mapear los datos de cada fila del Excel a las propiedades de los objetos que representan las células.
//   b) Configurar las columnas y sus títulos en la instancia de DataTables.
//   c) Generar las etiquetas en la vista de tarjetas.
// Ejemplo: ['#', 'ZONA', 'LIDER', 'DIRECCION', 'DIA', 'HORA', ...]
let headES = [];

// rows: El array principal que contendrá todos los datos de las células después de ser leídos y procesados.
// Cada elemento en este array es un objeto JavaScript. Cada propiedad de estos objetos
// corresponde a un encabezado de columna (definido en 'headES').
// A estos objetos se les añaden propiedades calculadas durante la ejecución:
//   - 'DIRECCION_FROM_EXCEL': La cadena de texto original de la dirección de la célula, tal como aparece en el archivo Excel.
//   - 'EFFECTIVE_ROUTING_ADDRESS': La dirección que se utilizará realmente para los cálculos de ETA.
//     Para las células de la zona "La Cosecha", será HUB_ADDR. Para otras, será su 'DIRECCION_FROM_EXCEL'.
//   - 'ETA_FROM_HUB': Un número que representa el tiempo estimado de llegada (en minutos) desde la iglesia (HUB_ADDR)
//     hasta la 'EFFECTIVE_ROUTING_ADDRESS' de la célula. Puede ser 'null' si no se pudo calcular.
//   - 'ETA_FROM_HOME': Un número que representa el tiempo estimado de llegada (en minutos) desde la dirección
//     introducida por el usuario hasta la 'EFFECTIVE_ROUTING_ADDRESS' de la célula. Se inicializa como 'null'.
let rows = [];

// table: Esta variable almacenará la referencia a la instancia de la DataTable una vez que se inicialice.
// A través de 'table', se puede acceder a la API de DataTables para realizar operaciones como
// limpiar la tabla (table.clear()), añadir nuevas filas (table.rows.add()), y redibujar la tabla (table.draw()).
let table;

// cardsDiv: Referencia al elemento <div> del DOM (con id='cards'). Este div es el contenedor
// donde se renderizará la información de las células en formato de "tarjetas" individuales.
// Esta vista de tarjetas se utiliza principalmente para una mejor experiencia en dispositivos móviles.
let cardsDiv;

// geocoder: Almacenará una instancia del servicio 'google.maps.Geocoder'.
// Este servicio se utiliza para la geocodificación, es decir, para convertir direcciones de texto
// (como "123 Calle Principal, Ciudad") en coordenadas geográficas (latitud y longitud), y viceversa.
let geocoder;

// distSvc: Almacenará una instancia del servicio 'google.maps.DistanceMatrixService'.
// Este servicio se utiliza para calcular la distancia y, más importante en este caso, el tiempo de viaje estimado
// entre uno o más puntos de origen y uno o más puntos de destino, considerando el modo de viaje (conducción).
let distSvc;

// homePos: Un objeto que almacenará las coordenadas geográficas (en formato {lat, lng}) de la
// dirección de casa que el usuario ha introducido y seleccionado.
// Se inicializa como 'null' y se actualiza cuando el usuario interactúa con el campo de Autocomplete
// o introduce una dirección que se geocodifica con éxito. Este estado es fundamental para
// determinar si se deben calcular y mostrar los ETAs desde la casa del usuario.
let homePos = null;

// geoCache: Un objeto 'Map' de JavaScript que actúa como una memoria caché para los resultados de geocodificación.
// La 'clave' en este Map es la cadena de dirección que se geocodificó.
// El 'valor' es el objeto de coordenadas {lat, lng} resultante, o 'null' si la geocodificación para esa dirección falló.
// El propósito de esta caché es evitar realizar llamadas repetidas a la API de Geocodificación de Google
// para la misma dirección dentro de una sesión, lo cual ayuda a optimizar el uso de la API y mejorar el rendimiento.
const geoCache = new Map();

/* ---------- FUNCIÓN AUXILIAR PARA FORMATEAR TÍTULOS DE COLUMNA ---------- */
// Esta función toma una cadena de texto 'str' y devuelve una nueva cadena donde
// la primera letra está en mayúscula y el resto de la cadena está en minúsculas.
// Se utiliza para formatear los encabezados de las columnas de la tabla y las etiquetas en las tarjetas.
// Maneja de forma segura entradas nulas, indefinidas o que no son cadenas, devolviendo una cadena vacía.
// Ejemplo: "ZONA" se convierte en "Zona".
// Ejemplo: "NOMBRE DEL MAESTRO/A" se convierte en "Nombre del maestro/a".
function formatHeaderTitle(str) {
  if (!str || typeof str !== 'string') return ''; // Si la entrada es inválida, devuelve una cadena vacía.
  // Toma el primer carácter de la cadena, lo convierte a mayúscula.
  // Luego, toma el resto de la cadena (desde el segundo carácter), lo convierte a minúsculas.
  // Finalmente, concatena ambas partes.
  return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase();
}

/* ---------- INICIALIZACIÓN DE GOOGLE MAPS ---------- */
// Esta función asíncrona ('async') se define como el 'callback' para la API de Google Maps.
// Se ejecuta automáticamente una vez que el script de la API de Google Maps se ha cargado completamente en la página.
async function gmapsReady() {
  // Crear instancias de los servicios de Google Maps necesarios para la aplicación.
  geocoder = new google.maps.Geocoder(); // Para convertir direcciones a coordenadas.
  distSvc = new google.maps.DistanceMatrixService(); // Para calcular distancias y tiempos de viaje.
  
  // Cargar y procesar los datos de las células desde el archivo Excel.
  // 'await' pausa la ejecución de 'gmapsReady' hasta que 'loadSheet' (que también es asíncrona) complete su tarea.
  // 'loadSheet' se encarga de leer el Excel, transformar los datos y, finalmente, llamar a 'buildUI'.
  await loadSheet();

  // Obtener el elemento del DOM que representa el campo de entrada de texto para la dirección de casa.
  const autocompleteInput = document.getElementById('homeInput');
  // Inicializar la funcionalidad de Autocomplete de Google Places en ese campo de entrada.
  // 'types: ['geocode']' restringe las sugerencias de Autocomplete a direcciones geocodificables (es decir, lugares que pueden ser mapeados).
  const ac = new google.maps.places.Autocomplete(autocompleteInput, { types: ['geocode'] });

  // Registrar un "listener" (oyente de eventos) para el evento 'place_changed' en la instancia de Autocomplete.
  // Este evento se dispara cuando el usuario selecciona una dirección de la lista de sugerencias que aparece debajo del campo de entrada.
  ac.addListener('place_changed', () => {
    const place = ac.getPlace(); // Obtener el objeto 'PlaceResult' con los detalles del lugar seleccionado por el usuario.
    const wasHomePosSet = !!homePos; // Guardar el estado anterior de 'homePos' (si tenía un valor o era null).
                                     // '!!' convierte el valor a un booleano explícito (true si homePos no era null, false si era null).

    // Actualizar la variable global 'homePos'.
    // Si 'place.geometry' existe (lo que significa que el lugar seleccionado tiene coordenadas geográficas válidas),
    // extraer la latitud y longitud y almacenarlas en 'homePos'.
    // Si no hay 'place.geometry' (ej., el usuario borró el texto del campo), establecer 'homePos' a 'null'.
    homePos = place.geometry ? { lat: place.geometry.location.lat(), lng: place.geometry.location.lng() } : null;

    // Lógica para manejar el caso en que la dirección de casa se borra DESPUÉS de que ya había sido establecida:
    if (!homePos && wasHomePosSet) { // Si 'homePos' es ahora nulo Y antes sí tenía un valor.
      document.getElementById('nearest').textContent = ''; // Borrar cualquier mensaje previo sobre la "célula más cercana".
      
      // Revertir el título del encabezado de la columna 'DIRECCION' en la DataTable a su estado inicial.
      const direccionOriginalHeaderKey = 'DIRECCION'; // Clave de datos de la columna.
      const direccionColumnIndex = headES.indexOf(direccionOriginalHeaderKey); // Obtener el índice de esta columna.
      if (direccionColumnIndex !== -1 && table) { // Verificar que la columna exista y la tabla esté inicializada.
        const column = table.column(direccionColumnIndex); // Obtener el objeto de columna de DataTables.
        // Actualizar el contenido HTML del elemento <th> del encabezado de la columna.
        // Usar 'formatHeaderTitle' para asegurar la capitalización correcta.
        $(column.header()).html(formatHeaderTitle('conducir desde la iglesia'));
      }
      
      // Refrescar la vista de la tabla y las tarjetas para que muestren los datos por defecto
      // (ETAs desde la iglesia, o el texto especial para la zona "La Cosecha"), ya que 'homePos' es ahora nulo.
      filterAndDisplayCells(); 
    }
    // Si 'homePos' se establece por primera vez, o cambia de una dirección válida a otra,
    // la función 'runSearch' (que se activa con el botón "Buscar" o la tecla Enter)
    // se encargará de realizar los nuevos cálculos de ETA desde casa y de actualizar
    // el encabezado de la columna 'DIRECCION' a "conduce desde tu casa".
  });

  // Añadir un "listener" de evento de clic al botón de búsqueda ('#searchBtn').
  // Cuando se hace clic en el botón, se llama a la función 'runSearch'.
  document.getElementById('searchBtn').addEventListener('click', runSearch);

  // Añadir un "listener" de evento de 'keypress' (pulsación de tecla) al campo de entrada de la dirección de casa ('#homeInput').
  // Esto permite al usuario iniciar la búsqueda presionando la tecla 'Enter' mientras el foco está en este campo.
  autocompleteInput.addEventListener('keypress', function(event) {
    if (event.key === 'Enter') { // Comprobar si la tecla presionada fue la tecla 'Enter'.
      event.preventDefault(); // Prevenir el comportamiento por defecto de la tecla 'Enter' en un campo de texto
                              // (que a menudo es intentar enviar un formulario, lo cual no aplica aquí).
      runSearch(); // Llamar a la función principal de búsqueda 'runSearch'.
    }
  });
}

/* ---------- PROCESAMIENTO DE DATOS DE EXCEL ---------- */
// Esta función asíncrona es responsable de cargar el archivo Excel 'celulas.xlsx',
// leer su contenido, transformar los datos en un formato utilizable (array de objetos),
// y realizar cálculos iniciales como el ETA desde la iglesia (HUB) a cada célula.
async function loadSheet() {
  try { // Usar un bloque try...catch para manejar posibles errores durante la carga o procesamiento del archivo.
    // 1. Obtener el archivo Excel. 'fetch' devuelve una Promesa que se resuelve en un objeto Response.
    const response = await fetch('celulas.xlsx');
    // 2. Leer el cuerpo de la respuesta como un ArrayBuffer. Esto es necesario porque SheetJS trabaja con datos binarios.
    const arrayBuffer = await response.arrayBuffer();
    // 3. Interpretar el ArrayBuffer como un libro de trabajo de Excel usando XLSX.read().
    const workbook = XLSX.read(arrayBuffer, { type: 'array' });

    // 4. Determinar el nombre de la hoja de cálculo a utilizar.
    //    Se prioriza una hoja llamada 'Consolidado'. Si no existe, se usa la primera hoja del libro.
    const sheetName = workbook.Sheets['Consolidado'] ? 'Consolidado' : workbook.SheetNames[0];
    const sheet = workbook.Sheets[sheetName]; // Obtener el objeto de la hoja de trabajo.
    
    // 5. Convertir los datos de la hoja a un formato de array de arrays usando SheetJS.
    //    'header: 1' indica que la primera fila de la hoja se tratará como datos, lo que permite extraer los encabezados manualmente.
    //    'defval: ''' asegura que las celdas vacías en el Excel se representen como cadenas vacías en lugar de 'undefined'.
    const sheetDataArray = XLSX.utils.sheet_to_json(sheet, { header: 1, defval: '' });
    
    // 6. Extraer los encabezados de la primera fila de 'sheetDataArray'.
    //    Cada encabezado se convierte a string y se le eliminan los espacios en blanco al inicio y al final.
    headES = sheetDataArray[0].map(h => String(h).trim());

    // 7. Procesar las filas de datos (todas las filas excepto la primera, que son los encabezados).
    rows = sheetDataArray.slice(1) // '.slice(1)' crea un nuevo array omitiendo el primer elemento (los encabezados).
             .filter(rowArray => rowArray.some(cellValue => cellValue !== '')) // Filtrar para excluir filas que estén completamente vacías.
                                                                            // '.some()' comprueba si al menos un valor de celda en la fila no es vacío.
             .map(rowArray => { // Transformar cada 'rowArray' (un array de valores de celda) en un objeto JavaScript.
               const rowObject = {}; // Crear un objeto vacío para esta fila.
               // Iterar sobre los encabezados ('headES'). Para cada encabezado, usarlo como clave
               // y el valor correspondiente de 'rowArray' (en la misma posición/índice) como valor.
               headES.forEach((header, index) => rowObject[header] = rowArray[index]);
               return rowObject; // Devolver el objeto de fila creado.
             })
             .filter(rowObject => { // Filtrar los objetos de célula resultantes según el idioma especificado en la columna 'IDIOMA'.
               const language = String(rowObject['IDIOMA']).toLowerCase(); // Obtener el valor, asegurar que sea string y convertir a minúsculas para una comparación insensible a mayúsculas.
               return language === 'español' || language === 'bilingüe'; // Mantener solo las células cuyo idioma sea 'español' o 'bilingüe'.
             });

    // 8. Procesar cada objeto de célula ('o') en el array 'rows' de forma asíncrona
    //    para añadir propiedades calculadas (dirección efectiva, ETAs).
    await Promise.all(rows.map(async (o) => {
      // Guardar la cadena de dirección original tal como se leyó de la columna 'DIRECCION' en el Excel.
      // Esta propiedad se llamará 'DIRECCION_FROM_EXCEL'.
      o['DIRECCION_FROM_EXCEL'] = o['DIRECCION']; // Asumimos que o['DIRECCION'] en este punto tiene el valor original del Excel.

      let effectiveAddressForRouting; // Esta variable almacenará la dirección que se usará para los cálculos de ETA.
      // Lógica especial para las células de la zona "La Cosecha".
      if (o['ZONA'] === 'La Cosecha') {
        // Si la célula pertenece a la zona "La Cosecha", su dirección efectiva para enrutamiento
        // se considera siempre la dirección de la iglesia (HUB_ADDR).
        effectiveAddressForRouting = HUB_ADDR;
      } else {
        // Para todas las demás zonas, la dirección efectiva para enrutamiento es la que figura en el Excel
        // (almacenada en 'DIRECCION_FROM_EXCEL').
        effectiveAddressForRouting = o['DIRECCION_FROM_EXCEL'];
      }
      // Almacenar esta dirección efectiva en el objeto de la célula. Se usará para calcular ETAs.
      o['EFFECTIVE_ROUTING_ADDRESS'] = effectiveAddressForRouting;

      // Calcular el ETA desde la iglesia (HUB_ADDR) hasta la 'EFFECTIVE_ROUTING_ADDRESS' de esta célula.
      // Para las células de "La Cosecha", esto implicará calcular el tiempo desde HUB_ADDR hasta HUB_ADDR,
      // lo cual debería resultar en 0 minutos o un valor muy pequeño.
      const etaHub = await driveMinutes(HUB_ADDR, o['EFFECTIVE_ROUTING_ADDRESS']);
      o['ETA_FROM_HUB'] = etaHub; // Almacenar el ETA numérico (en minutos). Será 'null' si el cálculo falla.

      // Inicializar la propiedad 'ETA_FROM_HOME' a 'null'. Esta se calculará más tarde,
      // cuando el usuario introduzca su dirección de casa y realice una búsqueda.
      o['ETA_FROM_HOME'] = null; 

      // NOTA IMPORTANTE: En este punto, NO se modifica la propiedad 'o['DIRECCION']'
      // para que contenga una cadena de ETA formateada (ej., "≈ 15 min").
      // Esa tarea ahora recae completamente en la función 'filterAndDisplayCells',
      // que construirá dinámicamente la cadena a mostrar en la columna 'DIRECCION'
      // según el contexto (si hay búsqueda de casa, si es zona "La Cosecha", etc.).
      // Aquí, o['DIRECCION'] sigue manteniendo el valor original leído del Excel para esa columna.
    }));

    // Una vez que todos los datos han sido cargados, transformados y procesados con ETAs iniciales,
    // llamar a 'buildUI' para construir y mostrar la interfaz de usuario (tabla, filtros).
    buildUI();
  } catch(e) { // Si ocurre cualquier error durante este proceso (ej., archivo no encontrado, error de parseo).
    // Mostrar un mensaje de error descriptivo en el elemento '#error' de la página.
    $('#error').show().text("Error cargando los datos de las células: " + e.message);
    // Registrar también el error detallado en la consola del navegador para facilitar la depuración.
    console.error("Error in loadSheet:", e);
  }
}

/* ---------- CONSTRUCCIÓN DE LA INTERFAZ DE USUARIO (UI CONSTRUCTION) ---------- */
// Esta función se llama después de que 'loadSheet' ha procesado los datos.
// Se encarga de inicializar la DataTable, poblar el filtro de zonas,
// y establecer los manejadores de eventos para los controles de la UI.
function buildUI() {
  // Llenar el menú desplegable del filtro de 'Zona' (#zonaSelect).
  // 1. Tomar el array 'rows', mapear para obtener solo los valores de la propiedad 'ZONA'.
  // 2. Filtrar para quitar valores 'falsy' (null, undefined, "", etc.) de las zonas.
  // 3. Crear un 'Set' a partir de esos valores para obtener una lista de nombres de zona únicos.
  // 4. Convertir el 'Set' de nuevo a un array (usando el operador de propagación '...') y ordenarlo alfabéticamente.
  // 5. Para cada nombre de zona único, crear un elemento HTML '<option>' y añadirlo al '<select>'.
  [...new Set(rows.map(r => r['ZONA']).filter(Boolean))].sort()
    .forEach(zone => $('#zonaSelect').append(`<option value="${zone}">${zone}</option>`));

  // Obtener los índices (posiciones) de las columnas '#' y 'ZONA' dentro del array de encabezados 'headES'.
  // Estos índices se usarán para configurar el ordenamiento inicial por defecto de la DataTable.
  // Si 'indexOf' no encuentra el encabezado, devuelve -1.
  const numIdx = headES.indexOf('#'); 
  const zonaIdx = headES.indexOf('ZONA'); 
  // Definir la clave (nombre de propiedad) que corresponde a la columna 'DIRECCION' en los objetos de datos.
  // Esta clave se usa para identificar esta columna específicamente cuando se configuran los títulos de las columnas.
  const direccionOriginalHeaderKey = 'DIRECCION'; 

  // Inicializar la DataTable en el elemento HTML con id 'tabla'.
  // '$('#tabla').DataTable(...)' es la forma de invocar DataTables en un elemento jQuery.
  table = $('#tabla').DataTable({
    // 'columns': Opción para definir las columnas de la DataTable. Se genera un array de objetos de configuración, uno por columna.
    columns: headES.map(originalHeaderName => { // Iterar sobre cada nombre de encabezado original de 'headES'.
      let displayTitle = originalHeaderName; // Por defecto, el título a mostrar es el mismo que el encabezado del Excel.
      
      // Lógica especial para el título de la columna 'DIRECCION'.
      if (originalHeaderName === direccionOriginalHeaderKey) {
        // Establecer el título inicial para esta columna ANTES de cualquier búsqueda de dirección de casa.
        displayTitle = 'conducir desde la iglesia'; 
      }
      // Formatear el 'displayTitle' (sea el original o el especial para 'DIRECCION')
      // para que la primera letra sea mayúscula y el resto minúsculas.
      displayTitle = formatHeaderTitle(displayTitle); 
      
      // Devolver el objeto de configuración para esta columna:
      // - 'title': El texto que se mostrará en el encabezado <th> de la columna en la tabla renderizada.
      // - 'data': El nombre de la propiedad en los objetos de datos (que están en 'rows')
      //   de la cual DataTables obtendrá el valor para las celdas de esta columna.
      return { title: displayTitle, data: originalHeaderName };
    }),
    // 'order': Configura el ordenamiento inicial de la tabla.
    // Es un array de arrays, donde cada subarray es [índiceDeColumna, 'asc'/'desc'].
    // Aquí, si se encontraron las columnas '#' y 'ZONA', se ordena primero por '#' ascendente, y luego por 'ZONA' ascendente.
    // Si no, no se aplica un ordenamiento inicial específico (DataTables podría usar el orden natural de los datos).
    order: (numIdx !== -1 && zonaIdx !== -1) ? [[numIdx, 'asc'], [zonaIdx, 'asc']] : [], 
    pageLength: 10 // Número de filas a mostrar por página cuando la paginación está activada.
  });
  // Obtener una referencia al elemento <div> (con id 'cards') que se usará para mostrar las tarjetas en vista móvil.
  cardsDiv = document.getElementById('cards');
  
  // Realizar la primera carga y renderizado de los datos en la tabla y en las tarjetas.
  // 'filterAndDisplayCells' se encarga de preparar los datos y actualizar ambas vistas.
  filterAndDisplayCells(); 

  // Añadir un "listener" para el evento 'change' en el menú desplegable del filtro de 'Zona' ('#zonaSelect').
  // Cuando el usuario seleccione una zona diferente:
  $('#zonaSelect').on('change', function() {
    // Se llamará a 'filterAndDisplayCells' para actualizar la tabla y las tarjetas
    // mostrando solo las células de la zona seleccionada (o todas si se elige "— Todas —").
    filterAndDisplayCells(); 
  });
}

/* ---------- FILTRADO Y VISUALIZACIÓN DE CÉLULAS (CELL FILTERING AND DISPLAY) ---------- */
// Esta función es crucial para mostrar los datos correctos en la tabla y las tarjetas.
// Se invoca inicialmente por 'buildUI' y cada vez que el filtro de zona cambia,
// o cuando se necesita refrescar la vista (ej., después de que 'homePos' se borra).
function filterAndDisplayCells() {
  // Obtener el valor actual del filtro de zona (el 'value' del <option> seleccionado).
  // Si es "— Todas —", 'selectedZone' será una cadena vacía "".
  const selectedZone = $('#zonaSelect').val();

  // Filtrar el array global 'rows' para obtener solo las filas que coinciden con la zona seleccionada.
  let currentFilteredRows;
  if (selectedZone) { // Si 'selectedZone' tiene un valor (es decir, no es la opción "— Todas —").
    currentFilteredRows = rows.filter(r => r['ZONA'] === selectedZone); // Filtrar por la zona.
  } else { // Si 'selectedZone' es "" (la opción "— Todas —" está seleccionada).
    // Usar una copia de todas las filas. El operador de propagación '[...rows]' crea una nueva copia superficial del array 'rows'.
    // IMPORTANTE (REQ#2): Esto asegura que si el usuario selecciona "Todas" después de una búsqueda de casa,
    // se procesen TODAS las células originales, no solo el subconjunto que pudo haberse mostrado previamente.
    currentFilteredRows = [...rows]; 
  }

  // Mapear sobre las 'currentFilteredRows' para crear un 'displayList'.
  // Cada elemento en 'displayList' será un objeto 'cellForDisplay', que es una copia
  // de los datos de una célula, pero con su propiedad 'DIRECCION' específicamente formateada para mostrar.
  const displayList = currentFilteredRows.map(cell => {
    // Crear una copia superficial del objeto 'cell' usando el operador de propagación.
    // Esto es importante para no modificar los objetos originales en el array 'rows'
    // cuando se establece la propiedad 'DIRECCION' para la visualización.
    const cellForDisplay = {...cell}; 

    // Lógica principal para determinar qué texto mostrar en la columna 'DIRECCION':
    if (homePos && typeof cell.ETA_FROM_HOME === 'number') { 
      // CASO 1: El usuario ha realizado una búsqueda de casa ('homePos' está establecido con coordenadas) Y
      // esta célula ('cell') tiene un valor numérico válido para 'ETA_FROM_HOME'.
      // En este caso, mostrar el ETA desde la casa del usuario.
      // Esto se aplica también a las células de la zona "La Cosecha", para las cuales 'ETA_FROM_HOME'
      // se habrá calculado respecto a HUB_ADDR (la iglesia).
      cellForDisplay['DIRECCION'] = `≈ ${cell.ETA_FROM_HOME} min`;
    } else { 
      // CASO 2: No se ha realizado una búsqueda de casa, o 'homePos' es nulo,
      // o esta célula específica no tiene un 'ETA_FROM_HOME' numérico válido.
      // Se recurre a la lógica de visualización por defecto (fallback).
      if (cell['ZONA'] === 'La Cosecha') {
        // Si la célula pertenece a la zona "La Cosecha", mostrar el texto estático especial.
        cellForDisplay['DIRECCION'] = 'Planta baja de la Iglesia (reunion general)';
      } else {
        // Para células de otras zonas, mostrar su ETA calculado desde el Hub (iglesia).
        // Si 'ETA_FROM_HUB' es nulo (ej., la dirección de la célula no era enrutable desde el hub), mostrar '—'.
        cellForDisplay['DIRECCION'] = cell.ETA_FROM_HUB != null ? `≈ ${cell.ETA_FROM_HUB} min` : '—';
      }
    }
    return cellForDisplay; // Devolver el objeto 'cellForDisplay' con la propiedad 'DIRECCION' formateada.
  });

  // Actualizar la DataTable con los datos de 'displayList', si la tabla está inicializada.
  if (table) { 
    table.clear(); // Eliminar todas las filas actualmente en la DataTable.
    table.rows.add(displayList); // Añadir los nuevos datos (el array 'displayList') a la DataTable.
    table.draw(); // Redibujar la DataTable para que los cambios (nuevas filas, paginación, etc.) sean visibles.
  }
  // Actualizar la vista de tarjetas con los datos de 'displayList', si el contenedor 'cardsDiv' existe.
  if (cardsDiv) { 
    renderCards(displayList); // Llamar a 'renderCards' para generar el HTML de las tarjetas.
  }
}


/* ---------- RENDERIZADO DE TARJETAS (CARD RENDERING) ---------- */
// Esta función genera el contenido HTML para la vista de tarjetas, que se usa en pantallas pequeñas (móviles).
// Recibe como argumento 'list', que es el 'displayList' preparado por 'filterAndDisplayCells'.
function renderCards(list) {
  // El 'list' contiene objetos 'cellObject' donde la propiedad 'DIRECCION' ya está formateada
  // correctamente para su visualización (sea un ETA, un texto especial, etc.).
  cardsDiv.innerHTML = list.map(cellObject => { // Iterar sobre cada 'cellObject' en la lista.
    // Para cada 'cellObject', construir el HTML de una tarjeta.
    // Se itera sobre 'headES' (los nombres de encabezado originales de las columnas del Excel).
    const lines = headES.map(header => {
      // Formatear el nombre del encabezado para usarlo como etiqueta en la tarjeta
      // (primera letra mayúscula, resto minúsculas).
      const displayHeader = formatHeaderTitle(header);
      // Crear una línea de texto HTML en formato "Etiqueta: Valor".
      // 'cellObject[header]' accede al valor de la propiedad correspondiente al 'header' en el 'cellObject'.
      return `<p><strong>${displayHeader}:</strong> ${cellObject[header]}</p>`;
    }).join(''); // Unir todas las líneas de texto en una sola cadena HTML.
    // Envolver las líneas generadas en un 'div' con la clase 'card' para aplicar estilos.
    return `<div class="card">${lines}</div>`;
  }).join(''); // Unir el HTML de todas las tarjetas generadas y asignarlo al 'innerHTML' de 'cardsDiv',
               // reemplazando cualquier contenido previo.
}

/* ---------- UTILIDADES DE GEOCODIFICACIÓN Y ETA (GEOCODING AND ETA UTILITIES) ---------- */
// Función auxiliar asíncrona para obtener coordenadas geográficas ({lat, lng}) para una 'locationInput'.
// 'locationInput' puede ser:
//   a) Una cadena de texto representando una dirección (ej., "123 Main St, Anytown").
//   b) Un objeto ya existente con propiedades 'lat' y 'lng' numéricas.
// Implementa un sistema de caché ('geoCache') para las cadenas de dirección para minimizar llamadas a la API.
async function getCoords(locationInput) {
  if (typeof locationInput === 'string') { // Si la entrada es una cadena de texto (se asume que es una dirección).
    // Comprobar primero si la dirección ya está en la caché 'geoCache'.
    if (geoCache.has(locationInput)) return geoCache.get(locationInput); // Si está, devolver el resultado cacheado.
    
    // Si no está en caché, realizar la geocodificación usando el servicio 'geocoder' de Google Maps.
    return new Promise(resolve => { // Devolver una Promesa, ya que 'geocoder.geocode' es asíncrono.
      geocoder.geocode({ address: locationInput }, (results, status) => {
        let loc = null; // Inicializar la variable de ubicación como null.
        // Comprobar si la solicitud de geocodificación fue exitosa ('OK') y si se obtuvieron resultados.
        if (status === 'OK' && results && results[0]) {
          // Si fue exitosa, extraer la latitud y longitud del primer resultado.
          // 'results[0].geometry.location' es un objeto google.maps.LatLng.
          // '.lat()' y '.lng()' son métodos para obtener los valores numéricos.
          loc = { 
            lat: results[0].geometry.location.lat(), 
            lng: results[0].geometry.location.lng() 
          };
        } else {
          // Si la geocodificación falla, registrar una advertencia en la consola.
          console.warn(`La geocodificación falló para la dirección "${locationInput}": ${status}`);
          // 'loc' permanecerá como null.
        }
        geoCache.set(locationInput, loc); // Almacenar el resultado (sea el objeto de coordenadas o null) en la caché.
        resolve(loc); // Resolver la Promesa con el objeto 'loc'.
      });
    });
  } else if (locationInput && typeof locationInput.lat === 'number' && typeof locationInput.lng === 'number') {
    // Si 'locationInput' ya es un objeto que parece tener coordenadas ('lat' y 'lng' son números),
    // se asume que es un objeto de coordenadas válido y se devuelve directamente.
    return locationInput; 
  }
  // Si 'locationInput' no es ni una cadena ni un objeto de coordenadas reconocido,
  // registrar una advertencia y devolver null.
  console.warn("Entrada de ubicación inválida para getCoords:", locationInput);
  return null; 
}

// 'gc' es un alias más corto para la función 'getCoords'. Puede usarse por conveniencia si se prefiere.
const gc = addr => getCoords(addr); 

// Función asíncrona para calcular el tiempo de conducción estimado en minutos entre un punto de origen y un punto de destino.
// 'originInput' y 'destinationInput' pueden ser cadenas de dirección o objetos de coordenadas {lat, lng}.
async function driveMinutes(originInput, destinationInput) {
  // Obtener los objetos de coordenadas para el origen y el destino usando la función 'getCoords'.
  // 'await' se usa porque 'getCoords' es asíncrona.
  const oCoords = await getCoords(originInput);
  const dCoords = await getCoords(destinationInput);
  
  // Si no se pudieron obtener las coordenadas para el origen o el destino (ej., direcciones inválidas),
  // no se puede calcular el ETA. Devolver null.
  if (!oCoords || !dCoords) return null;

  // Devolver una Promesa, ya que la llamada al servicio Distance Matrix de Google es asíncrona.
  return new Promise(resolve => {
    // Llamar al método 'getDistanceMatrix' del servicio 'distSvc'.
    distSvc.getDistanceMatrix({
      origins: [new google.maps.LatLng(oCoords.lat, oCoords.lng)], // Origen(s) como array de objetos google.maps.LatLng.
      destinations: [new google.maps.LatLng(dCoords.lat, dCoords.lng)], // Destino(s) como array de objetos google.maps.LatLng.
      travelMode: 'DRIVING', // Especificar el modo de viaje (otros pueden ser 'WALKING', 'TRANSIT', etc.).
      drivingOptions: { 
        departureTime: new Date() // Establecer la hora de salida como la actual. Esto permite al servicio
                                  // considerar las condiciones de tráfico actuales o típicas para la estimación del tiempo.
      } 
    }, (matrixResult, status) => { // Función callback que se ejecuta cuando el servicio responde.
                                  // 'matrixResult' contiene los datos de distancia/duración.
                                  // 'status' indica si la solicitud fue exitosa.
      // Acceder al elemento de resultado específico (para el primer origen y primer destino, ya que solo pedimos uno de cada).
      const element = matrixResult?.rows[0].elements[0]; 
      // Comprobar si el estado general de la solicitud ('status') Y el estado del elemento específico ('element.status') son 'OK'.
      if (status === 'OK' && element?.status === 'OK') {
        // Si el resultado es válido, obtener la duración del viaje.
        // Se prioriza 'duration_in_traffic' (si está disponible y el servicio lo proporciona), que estima el tiempo con tráfico.
        // Si no, se usa 'duration' (que podría ser una estimación sin tráfico o una estimación base).
        // El valor de la API viene en segundos, así que se divide por 60 y se redondea para obtener minutos.
        const durationInMinutes = Math.round((element.duration_in_traffic || element.duration).value / 60);
        resolve(durationInMinutes); // Resolver la Promesa con la duración en minutos.
      } else {
        // Si hubo un problema con la solicitud o el resultado específico, registrar una advertencia.
        console.warn(`DistanceMatrix falló entre ${JSON.stringify(oCoords)} y ${JSON.stringify(dCoords)}: ${status}, estado del elemento: ${element?.status}`);
        resolve(null); // Resolver la Promesa con null para indicar que el ETA no se pudo calcular.
      }
    });
  });
}

/* ---------- LÓGICA DE BÚSQUEDA DEL USUARIO ---------- */
// Esta función asíncrona se activa cuando el usuario introduce su dirección y pulsa "Buscar" o Enter.
// Se encarga de:
// 1. Validar la entrada del usuario y obtener las coordenadas de su casa.
// 2. Calcular el ETA desde su casa a todas las células (usando su 'EFFECTIVE_ROUTING_ADDRESS').
// 3. Actualizar el encabezado de la columna 'DIRECCION'.
// 4. Identificar las células "más cercanas" según el nuevo criterio (dentro de ETA de la más cercana + 3 minutos).
// 5. Mostrar un mensaje con la información de la célula absolutamente más cercana.
// 6. Actualizar la DataTable y las tarjetas para mostrar solo este subconjunto de células cercanas.
async function runSearch() {
  // Obtener el valor del campo de entrada de la dirección de casa y recortar espacios en blanco.
  const rawHomeAddress = document.getElementById('homeInput').value.trim();
  // Obtener el elemento DOM donde se mostrará el mensaje sobre la célula más cercana.
  const outNearestDiv = document.getElementById('nearest');
  // Obtener el elemento DOM del botón de búsqueda.
  const searchButton = document.getElementById('searchBtn');
  
  // --- Validación de la Entrada del Usuario y Geocodificación (si es necesario) ---
  // Si el campo de dirección está vacío, mostrar un mensaje y terminar la función.
  if (!rawHomeAddress) {
    outNearestDiv.textContent = 'Por favor, ingrese una dirección de casa.';
    return; 
  }
  // Si 'homePos' (coordenadas globales de la casa) aún no está establecido (ej., el usuario no usó Autocomplete, solo escribió y dio Enter)
  // Y el campo de dirección tiene texto, intentar geocodificar ese texto ahora.
  if (!homePos && rawHomeAddress) { 
      const loc = await getCoords(rawHomeAddress); // Intentar obtener coordenadas.
      if (!loc) { // Si la geocodificación de la entrada manual falla.
          outNearestDiv.textContent = 'Error: No se pudo geocodificar la dirección de casa ingresada.';
          return; 
      }
      homePos = loc; // Si tiene éxito, actualizar 'homePos' global.
  }
  // Si después de todos los intentos, 'homePos' sigue siendo nulo (la dirección proporcionada no es válida).
  if (!homePos) { 
    outNearestDiv.textContent = 'Error: Dirección de casa no válida o no seleccionada.';
    return; 
  }

  // --- Actualizaciones de UI para Indicar que la Búsqueda está en Progreso ---
  searchButton.disabled = true; // Deshabilitar el botón de búsqueda para evitar clics repetidos mientras se procesa.
  outNearestDiv.textContent = 'Buscando células cercanas…'; // Mostrar mensaje de "buscando".

  try { // Usar un bloque try...catch para manejar posibles errores durante las operaciones asíncronas (ETAs, etc.).
    // --- Cálculo de ETAs desde la Dirección de Casa del Usuario a Todas las Células ---
    // Crear un array de Promesas. Cada Promesa representa el cálculo del ETA para una célula.
    // Esto permite que los cálculos de ETA (que son llamadas a API) se realicen en paralelo.
    const promises = rows.map(async (cell) => { 
      // Para cada célula, calcular el ETA desde 'homePos' (casa del usuario)
      // hasta su 'EFFECTIVE_ROUTING_ADDRESS' (que es HUB_ADDR para zona "La Cosecha", o su propia dirección para otras).
      const eta = await driveMinutes(homePos, cell['EFFECTIVE_ROUTING_ADDRESS']);
      // Actualizar la propiedad 'ETA_FROM_HOME' del objeto 'cell' original (en el array 'rows').
      cell.ETA_FROM_HOME = eta; 
      return cell; // El 'return cell' aquí no es estrictamente necesario ya que 'rows' se modifica por referencia.
    });
    // Esperar a que todas las Promesas en el array 'promises' se resuelvan (es decir, todos los cálculos de ETA terminen).
    await Promise.all(promises); 

    // --- Actualización del Encabezado de la Columna 'DIRECCION' ---
    // Una vez que los ETAs desde casa han sido procesados (o al menos intentados),
    // actualizar el encabezado de la columna 'DIRECCION' para que diga "conduce desde tu casa".
    const direccionOriginalHeaderKey = 'DIRECCION';
    const direccionColumnIndex = headES.indexOf(direccionOriginalHeaderKey);
    if (direccionColumnIndex !== -1 && table) { // Solo si la columna existe y la tabla está inicializada.
      const column = table.column(direccionColumnIndex); // Obtener objeto de columna DataTables.
      // Aplicar formato de capitalización al nuevo título del encabezado.
      $(column.header()).html(formatHeaderTitle('conduce desde tu casa')); 
    }

    // --- Lógica para Seleccionar Células a Mostrar (Cercanas dentro de un Umbral) ---
    // 1. Crear un array de copias superficiales de las células para poder ordenarlas sin afectar el array 'rows' original.
    let cellsWithEta = rows.map(cell => ({...cell})); 
    // 2. Ordenar 'cellsWithEta' por la propiedad 'ETA_FROM_HOME' en orden ascendente.
    //    Las células con 'ETA_FROM_HOME' nulo (si falló el cálculo de su ETA) se colocarán al final.
    cellsWithEta.sort((a, b) => {
      if (a.ETA_FROM_HOME === null && b.ETA_FROM_HOME === null) return 0; // Si ambos son null, se consideran iguales.
      if (a.ETA_FROM_HOME === null) return 1;  // Si 'a' es null y 'b' no, 'a' va después ('a' es "mayor").
      if (b.ETA_FROM_HOME === null) return -1; // Si 'b' es null y 'a' no, 'b' va después ('b' es "mayor", 'a' es "menor").
      return a.ETA_FROM_HOME - b.ETA_FROM_HOME; // Comparación numérica estándar para ETAs válidos.
    });
    
    // 3. Filtrar 'cellsWithEta' para obtener solo aquellas células que tienen un 'ETA_FROM_HOME' válido (no nulo).
    const allCellsWithValidEta = cellsWithEta.filter(c => c.ETA_FROM_HOME !== null);
    
    // 4. Determinar qué células se mostrarán en la tabla y actualizar el mensaje de la más cercana.
    if (allCellsWithValidEta.length > 0) { // Si hay al menos una célula con un ETA válido desde casa.
      // La 'absoluteNearestCell' es la primera en la lista ordenada 'allCellsWithValidEta' (la que tiene el menor ETA).
      const absoluteNearestCell = allCellsWithValidEta[0]; 
      const minEtaValue = absoluteNearestCell.ETA_FROM_HOME; // El valor del ETA más corto.
      // Definir el umbral para mostrar células: ETA de la más cercana + 3 minutos.
      const etaThreshold = minEtaValue + 3; 

      // Filtrar 'allCellsWithValidEta' para obtener todas las células cuyo 'ETA_FROM_HOME'
      // esté dentro de este umbral (es decir, no más de 3 minutos adicionales respecto a la más cercana).
      const cellsToDisplayInTable = allCellsWithValidEta.filter(c => c.ETA_FROM_HOME <= etaThreshold);

      // Actualizar el mensaje de 'célula más cercana' ('outNearestDiv') con los detalles de la 'absoluteNearestCell'.
      outNearestDiv.textContent = `La célula más cercana (#${absoluteNearestCell['#']}) está a ≈ ${minEtaValue} min. ` +
                        `Maestro/a: ${absoluteNearestCell['MAESTRO']}, ` +
                        `Tel: ${absoluteNearestCell['TELEFONO']}.`;
      
      // Preparar la lista de células que se mostrarán en la tabla ('cellsToDisplayInTable').
      // Específicamente, formatear su propiedad 'DIRECCION' para que muestre el ETA desde casa.
      const displayDataForTable = cellsToDisplayInTable.map(cell => {
        const displayCell = {...cell}; // Crear una copia para la visualización.
        displayCell['DIRECCION'] = `≈ ${cell.ETA_FROM_HOME} min`; // Formatear la cadena de ETA.
        return displayCell;
      });

      // Actualizar la DataTable y las tarjetas con esta lista de células cercanas seleccionadas.
      if (table) { // Solo si la tabla ha sido inicializada.
        table.clear().rows.add(displayDataForTable).draw(); // Limpiar, añadir nuevas filas y redibujar.
      }
      renderCards(displayDataForTable); // Actualizar la vista de tarjetas.

    } else { // Si no se encontraron células con ETAs válidos desde casa (ej., todos los cálculos fallaron).
      outNearestDiv.textContent = 'No se encontraron células cercanas o no se pudo calcular el tiempo de viaje.';
      if (table) { // Si la tabla existe, limpiarla.
          table.clear().draw();
      }
      renderCards([]); // Mostrar una vista de tarjetas vacía.
    }

  } catch(e) { // Capturar cualquier error que pueda ocurrir durante el bloque 'try' (ej., error en API de Google).
    outNearestDiv.textContent = 'Error durante la búsqueda: ' + e.message;
    console.error("Error in runSearch:", e); // Registrar el error detallado en la consola para depuración.
  } finally { // El bloque 'finally' se ejecuta siempre, independientemente de si hubo un error o no.
    searchButton.disabled = false; // Volver a habilitar el botón de búsqueda para que el usuario pueda intentarlo de nuevo.
  }
}
</script>
</body>
</html>
