<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8"/>
<title>Células de Crecimiento | Zona</title>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<link rel="stylesheet"
      href="https://cdn.datatables.net/1.13.8/css/jquery.dataTables.min.css"/>
<style>
/* -------- Estilos CSS -------- */
body{font-family:system-ui,Arial,sans-serif;margin:0;background:#fafafa}
header .banner{display:block;width:100%;height:auto;max-height:25vh;object-fit:contain;margin:0}
.controls{margin:1rem 2rem;display:flex;flex-wrap:wrap;gap:.75rem;align-items:center}
#zonaSelect,#homeInput{padding:.35rem .6rem;font-size:1rem;border:1px solid #ccc;border-radius:4px}
#homeInput{min-width:260px;flex:1 1 260px}
#homeInput::placeholder{color:#999}
#searchBtn{padding:.35rem .9rem;font-size:1rem;border:1px solid #2d57a3;background:#2d57a3;color:#fff;border-radius:4px;cursor:pointer}
#searchBtn:disabled{opacity:.5;cursor:not-allowed}
.table-wrapper{height:65vh;overflow:auto;padding:0 2rem 1.5rem}
table.dataTable{border:2px solid #13284b;border-collapse:collapse;width:100%;table-layout:fixed}
table.dataTable thead th{background:#2d57a3;color:#fff;border:1px solid #13284b;font-weight:700;text-align:center}
table.dataTable td{border:1px solid #ccc;padding:6px 4px;word-wrap:break-word}
table.dataTable tbody td:nth-child(1){background:#eee;font-weight:700;text-align:center}
table.dataTable tbody tr:nth-child(even) td{background:#f8f8f8}
.cards{display:none;padding:0 1rem 2rem;overflow:auto;height:65vh}
.card{border:1px solid #ccc;border-radius:6px;margin-bottom:1rem;padding:1rem;background:#fff;box-shadow:0 1px 3px rgba(0,0,0,.05)}
.card p{margin:.25rem 0;font-size:.95rem}
@media(max-width:900px){
  .table-wrapper{display:none}
  .cards{display:block}
  .controls{margin:1rem}
}
#nearest{margin:.5rem 2rem 0;font-weight:600}
#error{color:#c00;margin:1rem 2rem 0;font-weight:700}
</style>
</head>
<body>
<header>
  <img src="./header.svg" class="banner" alt="La Cosecha – Células">
</header>

<div class="controls">
  <label for="zonaSelect"><strong>Zona:</strong></label>
  <select id="zonaSelect"><option value="">— Todas —</option></select>
  <label for="homeInput" class="addr-label">Buscar dirección más cercana:</label>
  <input id="homeInput" type="text" placeholder="Dirección de casa"/>
  <button id="searchBtn">Buscar</button>
</div>

<div id="nearest"></div>

<div class="table-wrapper"><table id="tabla" class="display"></table></div>
<div id="cards"  class="cards"></div>
<div id="error"  hidden></div>

<script src="./xlsx.full.min.js"></script>
<script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
<script src="https://cdn.datatables.net/1.13.8/js/jquery.dataTables.min.js"></script>
<script async defer
  src="https://maps.googleapis.com/maps/api/js?key=AIzaSyC4LU0O02a7lCRtZeyGbigQQcJ4EuSKa7A&libraries=places&callback=gmapsReady">
</script>

<script>
/* ==========================================================================
   Lógica JavaScript para la Aplicación Buscador de Células
   ========================================================================== */

/* ---------- CONSTANTES GLOBALES ---------- */
const HUB_ADDR = '600 Greenwich St, Hempstead, NY 11550';

/* ---------- ESTADO GLOBAL DE LA APLICACIÓN ---------- */
let headES = [];
let rows = [];
let table;
let cardsDiv;
let geocoder;
let distSvc;
let homePos = null;
const geoCache = new Map();

/* ---------- FUNCIÓN AUXILIAR PARA FORMATEAR TÍTULOS DE COLUMNA ---------- */
function formatHeaderTitle(str) {
  if (!str || typeof str !== 'string') return '';
  return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase();
}

/* ---------- INICIALIZACIÓN DE GOOGLE MAPS ---------- */
async function gmapsReady() {
  geocoder = new google.maps.Geocoder();
  distSvc = new google.maps.DistanceMatrixService();
  await loadSheet();

  const autocompleteInput = document.getElementById('homeInput');
  const ac = new google.maps.places.Autocomplete(autocompleteInput, { types: ['geocode'] });

  ac.addListener('place_changed', () => {
    const place = ac.getPlace();
    const wasHomePosSet = !!homePos;
    homePos = place.geometry ? { lat: place.geometry.location.lat(), lng: place.geometry.location.lng() } : null;

    if (!homePos && wasHomePosSet) {
      document.getElementById('nearest').textContent = '';
      const direccionOriginalHeaderKey = 'DIRECCION';
      const direccionColumnIndex = headES.indexOf(direccionOriginalHeaderKey);
      if (direccionColumnIndex !== -1 && table) {
        const column = table.column(direccionColumnIndex);
        $(column.header()).html(formatHeaderTitle('conducir desde la iglesia'));
      }
      filterAndDisplayCells(); 
    }
  });

  document.getElementById('searchBtn').addEventListener('click', runSearch);
  autocompleteInput.addEventListener('keypress', function(event) {
    if (event.key === 'Enter') {
      event.preventDefault();
      runSearch();
    }
  });
}

/* ---------- PROCESAMIENTO DE DATOS DE EXCEL ---------- */
async function loadSheet() {
  try {
    const response = await fetch('celulas.xlsx');
    const arrayBuffer = await response.arrayBuffer();
    const workbook = XLSX.read(arrayBuffer, { type: 'array' });
    const sheetName = workbook.Sheets['Consolidado'] ? 'Consolidado' : workbook.SheetNames[0];
    const sheet = workbook.Sheets[sheetName];
    const sheetDataArray = XLSX.utils.sheet_to_json(sheet, { header: 1, defval: '' });
    
    headES = sheetDataArray[0].map(h => String(h).trim());

    rows = sheetDataArray.slice(1)
             .filter(rowArray => rowArray.some(cellValue => cellValue !== ''))
             .map(rowArray => {
               const rowObject = {};
               headES.forEach((header, index) => rowObject[header] = rowArray[index]);
               return rowObject;
             })
             .filter(rowObject => {
               const language = String(rowObject['IDIOMA']).toLowerCase();
               return language === 'español' || language === 'bilingüe';
             });

    await Promise.all(rows.map(async (o) => {
      o['DIRECCION_FROM_EXCEL'] = o['DIRECCION']; 
      let effectiveAddressForRouting;
      if (o['ZONA'] === 'La Cosecha') {
        effectiveAddressForRouting = HUB_ADDR;
      } else {
        effectiveAddressForRouting = o['DIRECCION_FROM_EXCEL'];
      }
      o['EFFECTIVE_ROUTING_ADDRESS'] = effectiveAddressForRouting;
      const etaHub = await driveMinutes(HUB_ADDR, o['EFFECTIVE_ROUTING_ADDRESS']);
      o['ETA_FROM_HUB'] = etaHub; 
      o['ETA_FROM_HOME'] = null; 
    }));
    buildUI();
  } catch(e) {
    $('#error').show().text("Error cargando los datos de las células: " + e.message);
    console.error("Error in loadSheet:", e);
  }
}

/* ---------- CONSTRUCCIÓN DE LA INTERFAZ DE USUARIO (UI CONSTRUCTION) ---------- */
function buildUI() {
  [...new Set(rows.map(r => r['ZONA']).filter(Boolean))].sort()
    .forEach(zone => $('#zonaSelect').append(`<option value="${zone}">${zone}</option>`));

  const numIdx = headES.indexOf('#'); 
  const zonaIdx = headES.indexOf('ZONA'); 
  const direccionOriginalHeaderKey = 'DIRECCION'; 

  table = $('#tabla').DataTable({
    columns: headES.map(originalHeaderName => {
      let displayTitle = originalHeaderName;
      if (originalHeaderName === direccionOriginalHeaderKey) {
        displayTitle = 'conducir desde la iglesia'; 
      }
      displayTitle = formatHeaderTitle(displayTitle); 
      return { title: displayTitle, data: originalHeaderName };
    }),
    order: (numIdx !== -1 && zonaIdx !== -1) ? [[numIdx, 'asc'], [zonaIdx, 'asc']] : [], 
    pageLength: 10
  });
  cardsDiv = document.getElementById('cards');
  filterAndDisplayCells(); 

  // Se revierte al evento 'change' para el selector de Zona.
  // Este evento se dispara solo cuando el valor SELECCIONADO del dropdown CAMBIA.
  // Si el usuario hace clic en "— Todas —" y esta opción ya estaba seleccionada,
  // el evento 'change' NO se disparará, y la tabla no se refrescará en ese instante.
  // Para ver todas las filas después de una búsqueda (que muestra un subconjunto),
  // si "— Todas —" ya estaba seleccionado, el usuario necesitará primero seleccionar
  // OTRA zona, y LUEGO volver a seleccionar "— Todas —" para forzar un cambio de valor.
  $('#zonaSelect').on('change', function() {
    filterAndDisplayCells(); 
  });
}

/* ---------- FILTRADO Y VISUALIZACIÓN DE CÉLULAS (CELL FILTERING AND DISPLAY) ---------- */
function filterAndDisplayCells() {
  const selectedZone = $('#zonaSelect').val();
  let currentFilteredRows = selectedZone ? rows.filter(r => r['ZONA'] === selectedZone) : [...rows]; 

  if (homePos) { 
    currentFilteredRows.sort((a, b) => {
      if (a.ETA_FROM_HOME === null && b.ETA_FROM_HOME === null) return 0;
      if (a.ETA_FROM_HOME === null) return 1;  
      if (b.ETA_FROM_HOME === null) return -1; 
      return a.ETA_FROM_HOME - b.ETA_FROM_HOME; 
    });
  }
 
  const displayList = currentFilteredRows.map(cell => {
    const cellForDisplay = {...cell}; 
    if (homePos && typeof cell.ETA_FROM_HOME === 'number') { 
      cellForDisplay['DIRECCION'] = `≈ ${cell.ETA_FROM_HOME} min`;
    } else { 
      if (cell['ZONA'] === 'La Cosecha') {
        cellForDisplay['DIRECCION'] = 'Planta baja de la Iglesia (reunion general)';
      } else {
        cellForDisplay['DIRECCION'] = cell.ETA_FROM_HUB != null ? `≈ ${cell.ETA_FROM_HUB} min` : '—';
      }
    }
    return cellForDisplay;
  });

  if (table) { 
    table.clear().rows.add(displayList).draw();
  }
  if (cardsDiv) { 
    renderCards(displayList);
  }
}

/* ---------- RENDERIZADO DE TARJETAS (CARD RENDERING) ---------- */
function renderCards(list) {
  cardsDiv.innerHTML = list.map(cellObject => {
    const lines = headES.map(header => {
      const displayHeader = formatHeaderTitle(header);
      return `<p><strong>${displayHeader}:</strong> ${cellObject[header]}</p>`;
    }).join('');
    return `<div class="card">${lines}</div>`;
  }).join('');
}

/* ---------- UTILIDADES DE GEOCODIFICACIÓN Y ETA (GEOCODING AND ETA UTILITIES) ---------- */
async function getCoords(locationInput) {
  if (typeof locationInput === 'string') {
    if (geoCache.has(locationInput)) return geoCache.get(locationInput);
    return new Promise(resolve => {
      geocoder.geocode({ address: locationInput }, (results, status) => {
        let loc = null;
        if (status === 'OK' && results && results[0]) {
          loc = { 
            lat: results[0].geometry.location.lat(), 
            lng: results[0].geometry.location.lng() 
          };
        } else {
          console.warn(`La geocodificación falló para la dirección "${locationInput}": ${status}`);
        }
        geoCache.set(locationInput, loc);
        resolve(loc);
      });
    });
  } else if (locationInput && typeof locationInput.lat === 'number' && typeof locationInput.lng === 'number') {
    return locationInput; 
  }
  console.warn("Entrada de ubicación inválida para getCoords:", locationInput);
  return null; 
}

const gc = addr => getCoords(addr); 

async function driveMinutes(originInput, destinationInput) {
  const oCoords = await getCoords(originInput);
  const dCoords = await getCoords(destinationInput);
  if (!oCoords || !dCoords) return null;

  return new Promise(resolve => {
    distSvc.getDistanceMatrix({
      origins: [new google.maps.LatLng(oCoords.lat, oCoords.lng)],
      destinations: [new google.maps.LatLng(dCoords.lat, dCoords.lng)],
      travelMode: 'DRIVING',
      drivingOptions: { 
        departureTime: new Date() 
      } 
    }, (matrixResult, status) => {
      const element = matrixResult?.rows[0].elements[0];
      if (status === 'OK' && element?.status === 'OK') {
        const durationInMinutes = Math.round((element.duration_in_traffic || element.duration).value / 60);
        resolve(durationInMinutes);
      } else {
        console.warn(`DistanceMatrix falló entre ${JSON.stringify(oCoords)} y ${JSON.stringify(dCoords)}: ${status}, estado del elemento: ${element?.status}`);
        resolve(null);
      }
    });
  });
}

/* ---------- LÓGICA DE BÚSQUEDA DEL USUARIO ---------- */
async function runSearch() {
  const rawHomeAddress = document.getElementById('homeInput').value.trim();
  const outNearestDiv = document.getElementById('nearest');
  const searchButton = document.getElementById('searchBtn');
  
  if (!rawHomeAddress) {
    outNearestDiv.textContent = 'Por favor, ingrese una dirección de casa.';
    return;
  }
  if (!homePos && rawHomeAddress) { 
      const loc = await getCoords(rawHomeAddress);
      if (!loc) {
          outNearestDiv.textContent = 'Error: No se pudo geocodificar la dirección de casa ingresada.';
          return;
      }
      homePos = loc;
  }
  if (!homePos) { 
    outNearestDiv.textContent = 'Error: Dirección de casa no válida o no seleccionada.';
    return;
  }

  searchButton.disabled = true; 
  outNearestDiv.textContent = 'Buscando células cercanas…';

  try {
    const promises = rows.map(async (cell) => { 
      const eta = await driveMinutes(homePos, cell['EFFECTIVE_ROUTING_ADDRESS']);
      cell.ETA_FROM_HOME = eta; 
      return cell; 
    });
    await Promise.all(promises); 

    const direccionOriginalHeaderKey = 'DIRECCION';
    const direccionColumnIndex = headES.indexOf(direccionOriginalHeaderKey);
    if (direccionColumnIndex !== -1 && table) {
      const column = table.column(direccionColumnIndex);
      $(column.header()).html(formatHeaderTitle('conduce desde tu casa')); 
    }

    let cellsWithEta = rows.map(cell => ({...cell})); 
    cellsWithEta.sort((a, b) => {
      if (a.ETA_FROM_HOME === null && b.ETA_FROM_HOME === null) return 0;
      if (a.ETA_FROM_HOME === null) return 1;
      if (b.ETA_FROM_HOME === null) return -1;
      return a.ETA_FROM_HOME - b.ETA_FROM_HOME;
    });
    
    const allCellsWithValidEta = cellsWithEta.filter(c => c.ETA_FROM_HOME !== null);
    
    if (allCellsWithValidEta.length > 0) {
      const absoluteNearestCell = allCellsWithValidEta[0]; 
      const minEtaValue = absoluteNearestCell.ETA_FROM_HOME;
      const etaThreshold = minEtaValue + 3; 

      const cellsToDisplayInitially = allCellsWithValidEta.filter(c => c.ETA_FROM_HOME <= etaThreshold);

      outNearestDiv.textContent = `La célula más cercana (#${absoluteNearestCell['#']}) está a ≈ ${minEtaValue} min. ` +
                        `Maestro/a: ${absoluteNearestCell['MAESTRO']}, ` +
                        `Tel: ${absoluteNearestCell['TELEFONO']}.`;
      
      const displayDataForInitialTable = cellsToDisplayInitially.map(cell => {
        const displayCell = {...cell};
        displayCell['DIRECCION'] = `≈ ${cell.ETA_FROM_HOME} min`; 
        return displayCell;
      });

      // Después de una búsqueda, la tabla se actualiza para mostrar SOLO el subconjunto de células más cercanas.
      if (table) {
        table.clear().rows.add(displayDataForInitialTable).draw();
      }
      renderCards(displayDataForInitialTable);

      // Ya NO se llama proactivamente a filterAndDisplayCells() aquí si "Todas" estaba seleccionado.
      // El usuario debe interactuar explícitamente con el filtro de Zona para cambiar la vista de la tabla
      // de este subconjunto de "más cercanas" a una vista de zona específica o a "todas" las células.
      // Si el usuario selecciona "— Todas —" (y esto representa un *cambio* en el valor del select),
      // el listener 'change' en #zonaSelect llamará a filterAndDisplayCells(), que entonces mostrará todas las filas,
      // ordenadas por ETA desde casa.

    } else { 
      outNearestDiv.textContent = 'No se encontraron células cercanas o no se pudo calcular el tiempo de viaje.';
      if (table) {
          table.clear().draw();
      }
      renderCards([]);
    }

  } catch(e) {
    outNearestDiv.textContent = 'Error durante la búsqueda: ' + e.message;
    console.error("Error in runSearch:", e);
  } finally {
    searchButton.disabled = false;
  }
}
</script>
</body>
</html>
